[[段描述符]]
[[段和页]]
[[寄存器]]

## （内存分段管理）

| 模式       | 段的本质                                          |
| -------- | --------------------------------------------- |
| **实模式**  | 段只是地址拼接的手段（段寄存器×16 + 偏移），没有保护功能。              |
| **保护模式** | 段是由CPU硬件管理的内存区域，有**边界**（长度）、**权限**、**类型**等属性。 |

- **在实模式下，==每个段的长度都是固定的——64KB==（65536字节）**（对应那个16位寄存器）。实模式下段 **直接对应物理内存**

在保护模式中，段真正成为一个“被定义的内存区域”，它拥有==起始地址、长度、权限==等属性，由CPU进行访问==检查==。

- **段（Segment）**：
    
    - 是 CPU 和操作系统在==**逻辑地址/虚拟地址层面**的管理单位==
        
    - 描述段基址 + 段界限 + 权限
        
    - 段给出的是线性地址（虚拟地址）范围，不直接对应物理内存
        
- **物理内存（Physical Memory）**：
    
    - 是硬件实际的内存芯片
        
    - 物理==页框（Page Frame）才是操作系统管理物理内存的单位==
        
    - 物理内存本身没有段的概念

## 1️⃣ 分段的目的

- **隔离内存**：不同程序或内核/用户空间段互不干扰
    
- **提供访问控制**：可读/可写/可执行权限
    
- **便于管理**：把内存按逻辑功能划分（代码、数据、栈）
    

---

## 2️⃣ 分段单位

在 x86 保护模式下：

1. **段寄存器**（CS、DS、SS、ES、FS、GS）
    
    - 每个寄存器保存一个段选择子
        
    - 指示访问哪个段
        
2. **段选择子**
    
    - 16 位
        
    - **索引段描述符**（GDT 或 LDT）
        
    - 包含请求特权级（RPL）和表指示符（TI）
        
3. **段描述符**（8 字节）
    
    - 包含段基址、段界限、权限等信息
        
    - 定义段的虚拟地址范围和访问权限
        

---

## 3️⃣ 操作系统如何建立段

### (1) 内核段

- 通常操作系统在 **GDT（全局描述符表）** 中建立
    
- 内核代码段（Kernel Code Segment）：可执行、只读、特权级 0
    
- 内核数据段（Kernel Data Segment）：可读写、特权级 0
    
- 内核栈段（Stack Segment）：可读写、特权级 0
    
- 所有进程共用这些内核段，保证内核在特权级执行时可以访问
    

### (2) 用户段

- 用户态代码段（User Code Segment）：可执行、只读、特权级 3
    
- 用户态数据段（User Data Segment）：可读写、特权级 3
    
- 用户态栈段（User Stack Segment）：可读写、特权级 3
    
- 每个进程有自己的 LDT 或通过 GDT 中不同描述符分配段
    

### (3) 映射 ELF 文件段

- Loader 将 ELF 文件的段加载到虚拟地址空间
    
- 操作系统会选择合适的段（段描述符）覆盖该虚拟地址范围
    
- CPU 访问逻辑地址时通过段选择子 + 偏移访问对应段
    

---

## 4️⃣ 分段规则

- **段连续吗？**
    
    - 段在逻辑上连续，但可以跨多个页（分页机制下）
        
- **段大小**
    
    - 由段描述符的界限（Limit）指定
        
    - 可以设置粒度（字节或 4KB）
        
- **权限**
    
    - 不同段有不同访问权限（可读/可写/可执行）
        
    - 特权级（CPL / DPL）控制用户/内核访问
        

---

## 5️⃣ 举例（简单虚拟地址分段）

|段|段寄存器|基址|权限|说明|
|---|---|---|---|---|
|内核代码|CS(Kernel)|0xC0000000|可执行只读|内核执行代码|
|内核数据|DS(Kernel)|0xC0000000|可读写|全局数据、内核栈|
|用户代码|CS(User)|0x08048000|可执行只读|ELF 文件加载代码|
|用户数据|DS(User)|0x08049000|可读写|ELF 文件数据段|
|用户栈|SS(User)|0xBFFFF000|可读写|栈空间|

> CPU 访问内存时：
> 
> `逻辑地址 = 段选择子 + 偏移 段选择子 → 段描述符 → 段基址 + 权限 线性地址 → 页表 → 物理内存`

---

💡 **总结理解**

1. **段是逻辑划分单位**，CPU用段选择子 + 段描述符访问
    
2. **操作系统建立段**：
    
    - 内核段：全局共享
        
    - 用户段：每个进程独立
        
    - ELF 文件段加载到虚拟地址空间 → 映射到段
        
3. **段+页结合**：段确定线性地址范围和权限，页决定物理内存映射

[[段和页]]
**段和页结合使用时**：

1. CPU 用段选择子 + 偏移 → 得到线性地址（逻辑地址转换）
    
2. 分页机制把线性地址划分为页 → 通过页表映射到物理页框
    
3. 物理页框存放段内容的一部分
    

- 换句话说：==**段决定线性地址范围和权限，页表把线性地址映射到物理页框 → 内存实际存放段的一部分**==

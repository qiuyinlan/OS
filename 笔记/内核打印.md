**1️⃣ put_char（打印单个字符） → 2️⃣ put_str（打印字符串） → 3️⃣ put_int（打印整数）**。

## 一、从 `put_char()` 开始（打印一个字符）

先不看汇编，我们用**图和比喻**讲清楚 CPU 实际做的事。

### 💡 思路

我们写一个函数：

`void put_char(char ch);`

作用是：把一个字符（比如 `'A'`）显示在屏幕上。

要做到这件事，CPU 必须做三步：

|步骤|做什么|举例|
|---|---|---|
|1|找出现在光标在哪|比如在屏幕第 3 行第 5 格|
|2|往显存相应位置写入字符和颜色|把 `'A'` 写到对应内存|
|3|更新光标|光标右移到下一个格子|

---

### 🧠 细节展开

#### 🩵（1）获取光标位置

- VGA 控制器里有两个寄存器，专门存光标的位置（高8位和低8位）。
    
- 它们的编号是 `0x0E`（高位） 和 `0x0F`（低位）。
    
- 想读它们的值，要先告诉 VGA：“我要读光标寄存器”，再从端口拿值。
    

这时候读出来的值（0~2000）表示：

`第几个格子 = 行号 * 80 + 列号`

例如光标在第 2 行第 5 格 → `pos = 2*80 + 5 = 165`。

---

#### 💙（2）写入字符到显存

显存起点是 `0xB8000`，每个格子占两个字节：

`[0xB8000 + pos*2]     = 字符 [0xB8000 + pos*2 + 1] = 颜色`

举例：

`mov byte [0xB8000 + pos*2], 'A' mov byte [0xB8000 + pos*2 + 1], 0x07  ; 黑底白字`

这两句一执行，屏幕就出现一个白色的 A。



## 二、特殊字符处理

我们的 `put_char()` 除了显示普通字母，还要识别一些特殊字符：

| 字符   | 作用                |
| ---- | ----------------- |
| `\n` | 换行                |
| `\b` | 退格（光标往左移动一个格子并清空） |
| 普通字符 | 直接显示              |

---

## 💻 三、那为什么用汇编实现？

因为：

- 访问显存（0xB8000）和端口（0x3D4/0x3D5）都属于**硬件操作**；
    
- C 语言做不到这些；
    
- 所以内核的打印函数底层是汇编写的，然后在 C 头文件里声明。
    

比如：

`// print.h void put_char(uint8_t ch);`

这样，C 文件就能直接调用汇编写的函数。



你平时 `#include` 的那些 `.h` 文件，只是告诉编译器函数**长什么样**，  
而函数**真正的实现**其实早就编译在==系统的库文件里==（比如 `libc.so`、`libm.a`）
内核启动时：

[[标准库libc]]
- 根本**没有操作系统环境**，
    
- 也**没有标准库**（libc.so 不存在），
    
- 所以所有函数都得自己造。
    

也就是说：

> 内核不能用系统提供的 printf，因为操作系统自己还没运行。


所以没有库，c写声明，内核写原型。
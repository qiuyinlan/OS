CPU保护模式下的**段机制得到的线性地址**和分页机制下的**页**之间的关系
（由段的关系得到具体的地址，页会划分地址）
## 1️⃣ 地址转换流程

1. **逻辑地址（Logical Address）**
    
    - CPU 寄存器中存放段选择子 + 偏移
        
    - **段选择子** → 索引 GDT/LDT，取到 **段描述符**
        
    - **段描述符** → 提供 **段基址 + 界限 + 权限**
        
    - **逻辑地址 → 线性地址（Linear Address / 虚拟地址）**
        
2. **线性地址（Linear Address）**
    
    - 得到的线性地址就是分页机制要处理的地址
        
    - 如果分页未启用 → 线性地址就是物理地址
        
    - 如果分页启用 → 线性地址通过 **页表**映射到物理页框 → 物理地址
        

---

## 2️⃣ 段和页的关系

- **段是高层逻辑单位**
    
    - ==描述一块虚拟地址范围和访问权限==
        
    - 线性地址范围 = 段基址 + 偏移
        
- **页是分页机制下的内存管理单位**
    
    - 线性地址被划分为 **虚拟页号 + 页内偏移**
        
    - 页表把虚拟页号映射到物理页框
        
- **叠加关系**：
    
    1. CPU 用段机制把逻辑地址转换为线性地址
        
    2. ==分页机制把线性地址划分为页 → 页表映射到物理内存==
        

> **所以段和页不是上下级关系，而是两种不同的机制叠加**：
> 
> - 段：控制线性地址范围和访问权限
>     
> - 页：管理线性地址到物理内存的映射
>     

---

## 3️⃣ 举例（x86，保护模式 + 分页）

假设：

- 段基址 `0x10000000`
    
- 逻辑偏移 `0x00003000`
    

**步骤**：

1. 线性地址 = 段基址 + 偏移 = `0x10003000`
    
2. 页大小 4KB → 虚拟页号 = `0x10003000 / 0x1000 = 0x10003`
    
3. 页表查找 `0x10003` → 得到物理页框号 = `0x2000`
    
4. 物理地址 = 物理页框号 * 页大小 + 页内偏移 = `0x20003000`
    

> 段提供起始位置和范围，页提供具体物理位置。
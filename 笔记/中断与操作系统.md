没有中断，操作系统都运行不了。

“没有中断，操作系统几乎什么都做不了，操作系统是中断驱动的。”——这句话是非常经典的操作系统观点。要理解它，可以从两个核心点出发：**操作系统的本质是一个死循环**，以及 **操作系统是被动工作的**。

---

## **一、操作系统本质上是一个死循环**

操作系统并不是一段执行完就退出的程序。  
它必须 **永远运行在内核态**，持续掌控 CPU，否则 CPU 不知道该去哪里执行代码。

可以把它抽象成：

`while (1) {     // 操作系统的核心循环 }`

为什么要这样？

- 如果 OS 不循环，CPU 执行到结尾后会继续往后跑（变成“脱缰野马”）
    
- 可能把后面随机的内存当成指令执行
    
- 或者遇到无效指令抛出异常（Undefined/Invalid Opcode）
    

所以，**死循环的目的并不是“做很多事”，而是保持 OS 永远在场，不会退出。**

---

## **二、操作系统的死循环本身不主动做事**

这很重要！

这个循环本身不会主动去做：

- 读磁盘
    
- 收网络包
    
- 管理进程
    
- 切换任务
    
- 响应键盘/鼠标
    
- 分配内存
    

它真正做的事情很少，它 **主要是在等事情发生。**

---

## **三、操作系统是被动的，它只在事件发生时工作**

操作系统不是主动扫描所有事件，而是 **当硬件或软件发生事件时，通过“中断”通知操作系统**。

这意味着：

- 硬件有事干 → 发中断
    
- 软件请求服务（系统调用） → 触发软中断
    
- 定时器时间片到了 → 触发时钟中断
    
- 键盘敲击 → 键盘控制器发中断
    
- NIC 收到网络包 → 网卡发中断
    
- 块设备读写完成 → 设备发中断
    

**OS 的大部分工作都是在接到中断后才被动执行。**

也就是说：

> **事件 → 中断 → OS 开始工作**

没有事件，也就没有必要做事。

---

## **四、因此：操作系统是典型的“中断驱动系统”**

因为操作系统真正的执行流程是：

`等待事件 ↓（设备/软件触发） 中断产生 ↓ OS 的中断处理程序被调用 ↓ OS 执行相应功能（调度、IO处理、系统调用处理…） ↓ 回到死循环继续等待`

所以说：

- 操作系统 **不主动“干活”**
    
- 它 **只在中断来时工作**
    
- 中断是操作系统运作的“开关”
    
- 没有中断，OS 几乎不会做任何实质性的事
    

这就是“操作系统是中断驱动的”的真正含义。
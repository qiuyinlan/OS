## 1️⃣ TSS 是什么？

- **全称**：Task State Segment（==任务状态段==）
    
- **本质**：==一块内存结构，用来保存任务（Task）的状态信息==
    
- 包含内容：
    
    - **寄存器状态**：EIP、EFLAGS、通用寄存器（EAX、EBX…）
        
    - **段寄存器值**：CS、DS、ES、SS、FS、GS
        
    - **堆栈指针**：ESP0/ESP1/ESP2（针对不同特权级）
        
    - **堆栈段选择子**：SS0/SS1/SS2
        
    - **I/O 位图**：任务可访问 I/O 端口权限
        
- 每个任务有一个 TSS，==CPU 在任务切换时参考 TSS 保存和恢复状态==
    

---

## 2️⃣ TSS 在保护模式下的主要作用

### ① 特权级切换时的堆栈切换

- 用户态（CPL=3）调用内核（CPL=0）时：
    
    - CPU **不能使用用户态堆栈**，否则内核可能被破坏
        
    - ==CPU 会查 **TSS 中 ESP0 和 SS0**，切换到内核堆栈执行内核代码==
        
- 对应不同特权级的堆栈：
    
    - ESP0/SS0 → CPL=0 时使用
        
    - ESP1/SS1 → CPL=1 时使用
        
    - ESP2/SS2 → CPL=2 时使用
        

> 简单理解：TSS 就像“内核堆栈登记簿”，告诉 CPU 在特权级切换时该用哪块堆栈。

---

### ② 保存任务状态（可选任务切换）

- TSS 可以用在 **硬件任务切换（Hardware Task Switching）**
    
- 保存任务寄存器状态，切换任务时 CPU 自动加载 TSS
    
- 现代 OS（如 Linux）通常只用 TSS 来做 **堆栈切换**，不使用硬件任务切换
    

---

### ③ I/O 访问权限控制

- TSS 中有 **I/O 位图（I/O Permission Bitmap）**
    
- 用来控制任务能否访问特定 I/O 端口
    
- ==CPU 检查 CPL，如果 CPL 不够高且 I/O 权限未开放 → 禁止访问==
    

---

## 3️⃣ 总结 TSS 作用

| 功能       | 描述                                      |
| -------- | --------------------------------------- |
| 特权级切换堆栈  | 用户态 → 内核态时，CPU 用 TSS 中的 ESP0/SS0 切换内核堆栈 |
| 保存任务状态   | 支持硬件任务切换（寄存器、段寄存器、EIP、EFLAGS 等）         |
| I/O 权限控制 | 控制任务访问端口，结合 CPL 实现安全访问                  |

> 核心：在保护模式下，TSS **主要负责特权级切换时的安全堆栈切换**，确保内核态运行环境安全。

---


# IOPL

## 1️⃣ IOPL 是什么？

- **全称**：I/O Privilege Level（I/O 特权级）
    
- **存储位置**：CPU 的 **EFLAGS 寄存器的 12、13 位**
    
- **范围**：0（最高特权）～3（最低特权，与 CPL 相同）
    
- **作用**：控制程序对 I/O 指令（如 `IN`/`OUT`）的访问权限
    

> 简单理解：IOPL 是 **CPU 全局的“门槛”**，规定当前程序可以执行 I/O 指令的最低特权级。

---

## 2️⃣ IOPL 如何限制访问 I/O 端口？

1. **CPU 检查规则**
    

- 当程序执行 `IN`/`OUT` 等 I/O 指令时，CPU 会检查：
    

`允许访问 I/O 端口 <=> CPL ≤ IOPL`

- **例子**：
    
    - CPL=0（内核） → 可以访问所有端口
        
    - CPL=3（用户） + IOPL=0 → CPU 拒绝执行 I/O 指令
        
    - CPL=3 + IOPL=3 → CPU 允许执行
        

2. **结合 TSS I/O 位图**
    

- CPU 会进一步检查 **当前任务的 TSS 中 I/O 位图**
    
    - 位图中每一位对应一个==端口==：0=允许访问，1=禁止访问
        
    - CPU 在执行 I/O 指令时，如果位图对应位禁止访问 → 产生异常（#GP）
        

> 所以 IOPL 是 **全局门槛**，TSS I/O 位图是 **细粒度控制**。

---

## 3️⃣ 控制外设访问权限的机制

- I/O 指令直接操作外设端口（如键盘、串口、硬盘控制器）
    
- **保护模式下的安全机制**：
    
    1. **IOPL 检查** → 只允许特权程序（内核或系统服务）执行 I/O 指令
        
    2. **TSS I/O 位图检查** → 控制任务可访问哪些端口
        
- **效果**：
    
    - 用户态程序不能直接读写硬件端口
        
    - 防止破坏系统或干扰其他任务
        

---

## 4️⃣ 总结

|名称|作用|检查逻辑|
|---|---|---|
|IOPL|全局 I/O 特权级|CPL ≤ IOPL 才允许执行 I/O 指令|
|TSS I/O 位图|每任务可访问端口控制|指定端口是否允许访问|

💡 核心：

- **IOPL**：控制“能否执行 I/O 指令”，全局粗粒度
    
- **TSS I/O 位图**：控制“哪些端口可访问”，任务级细粒度
    

> 总结一句话：IOPL + TSS I/O 位图联合工作，实现 **安全的 I/O 端口访问控制**，防止低特权程序破坏硬件或系统。

---

## 位图是什么

- **TSS 位图**本质是一个 ==**二进制数组**==
    
- 每一位对应一个 ==I/O 端口==编号
    
    - 比如端口 `0x3F8` → 位图的第 `0x3F8` 位
        
- CPU 根据位图判断当前任务是否有权访问该端口
    

> 举例：

```
TSS I/O 位图:
端口: 0x3F8 0x3F9 0x3FA ...
位:     0    1    0
解释：
0x3F8 允许访问
0x3F9 禁止访问
0x3FA 允许访问


```



## 1️⃣ 普通段访问（CS/DS/ES/…）

- CPU 在访问段时，只需要检查 **CPL、RPL、DPL**：
    

`访问允许 ⇔ max(CPL, RPL) ≤ DPL`

- **没有位图**
    
- 原因：
    
    - 段访问是 **逻辑地址空间访问**
        
    - 内核只需要保证特权级安全即可
        
    - 不需要管“具体端口”，只要 CPL 满足 DPL 就可以访问段
        

✅ 例子：用户程序访问自己数据段（DPL=3），CPL=3 → 直接允许

---

## 2️⃣ I/O 指令访问（IN/OUT）

- CPU 执行 I/O 指令时，需要两级检查：
    
    1. **IOPL 检查**（粗粒度）
        
        - CPL ≤ IOPL → 有权执行 I/O 指令
            
    2. **TSS I/O 位图检查**（细粒度）
        
        - 对应端口的位=0 → 允许访问
            
        - 位=1 → 禁止访问，产生 #GP 异常
            
- **原因**：
    
    - I/O 端口是硬件资源，不同任务可能只允许访问部分端口



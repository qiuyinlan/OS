# 内存分段机制

[[实模式]] [[段]] [[段寄存器]] [[保护模式]]

## 分段机制产生的原因

### 硬件矛盾

- **8086 CPU 寄存器**：16 位
- **物理地址总线**：20 位
- **矛盾**：16 位寄存器最多表示 64KB，但地址总线能访问 1MB 内存

### 解决方案：分段

Intel 发明了内存分段机制：

```
物理地址 = 段基址 × 16 + 偏移地址
         = 段基址 << 4 + 偏移
```

- 段基址用**段寄存器**存储（16位）
- 偏移地址也是 16 位
- 两者组合成 20 位物理地址

参见：[[实模式]]

## 段寄存器

### 四个主要段寄存器

| 段寄存器 | 全称 | 用途 | 配合寄存器 |
|---------|------|------|-----------|
| **CS** | Code Segment | 代码段 | IP |
| **DS** | Data Segment | 数据段 | BX, SI, DI |
| **SS** | Stack Segment | 栈段 | SP, BP |
| **ES** | Extra Segment | 附加段 | DI |

### 为什么需要多个段寄存器？

1. **代码、数据、栈分开管理**
   - 如果只有一个段寄存器，程序小可以，但复杂程序容易访问越界
   - 栈操作可能覆盖数据

2. **支持字符串或块操作**
   - `movs` 指令：DS:SI → ES:DI 复制内存块
   - DS 指源段，ES 指目标段

3. **提高灵活性和安全性**
   - CPU 可以在不同段操作，不会互相干扰
   - 后续保护模式可以利用段保护内存

参见：[[段寄存器]]

## 地址计算

### 物理地址计算公式

```
物理地址 = 段基址 × 16 + 偏移
```

#### 为什么是 "×16" ？

因为段基址要**左移 4 位**（相当于 ×16）：

```
段基址:   0x1234
左移4位:  0x12340
加偏移:   0x12340 + 0x5678 = 0x17EB8
```

### 示例计算

```
CS = 0x1000
IP = 0x0010

物理地址 = 0x1000 × 16 + 0x0010
         = 0x10000 + 0x0010
         = 0x10010
```

## 段的特点

### 实模式下的段

| 特性 | 说明 |
|-----|------|
| 段大小 | 固定 64KB（16位偏移）|
| 段基址 | 可以是任意值 |
| 段重叠 | 允许段之间重叠 |
| 权限 | 无权限控制 |
| 类型 | 无类型区分 |

### 保护模式下的段

| 特性 | 说明 |
|-----|------|
| 段大小 | 可变，由段描述符指定 |
| 段基址 | 32位，可以指向任意地址 |
| 段重叠 | 由操作系统控制 |
| 权限 | 有读/写/执行权限 |
| 类型 | 代码段/数据段/系统段 |

参见：[[段]] [[段描述符]]

## 高端内存回卷

### 什么是回卷？

在实模式下，如果段基址+偏移超过 1MB：

```
段基址 = 0xFFFF
偏移   = 0xFFFF
计算   = 0xFFFF × 16 + 0xFFFF = 0x10FFEF
```

但地址总线只有 20 位，最高位被截断：

```
0x10FFEF → 0x0FFEF (回卷到低地址)
```

### 为什么会回卷？

- 地址总线只有 20 根线
- 超过 20 位的部分会被丢弃
- 就像时钟：13点 = 1点（模12）

## 栈段的特点

### 栈向下增长

```
栈底（高地址）
    ↓
    ↓  (栈向下增长)
    ↓
栈顶（低地址）← SP 指向这里
```

- **SS**：栈段基址（栈底）
- **SP**：栈顶指针（当前栈顶的偏移）

### 栈操作

```nasm
push ax    ; SP -= 2, [SS:SP] = AX
pop ax     ; AX = [SS:SP], SP += 2
```

参见：[[栈与指针]]

## 内存分区 vs 内存分段

### 内存分区（软件层面）

- **操作系统/编译器**规划的内存区域
- 例如：代码区、数据区、堆区、栈区
- 逻辑管理层面的划分

### 内存分段（硬件层面）

- **CPU 硬件**的访问方式
- 规定地址怎么算（段基址×16+偏移）
- 物理访问层面的机制

### 两者关系

| 概念 | 层次 | 控制者 | 作用 |
|-----|------|--------|------|
| 分段 | 硬件层 | CPU | 扩展寻址能力 |
| 分区 | 软件层 | OS/编译器 | 组织内存、管理数据 |

## 为什么需要初始化段寄存器？

### MBR 中的段初始化

```nasm
mov ax, cs
mov ds, ax
mov es, ax
mov ss, ax
mov fs, ax
mov sp, 0x7c00
```

#### 原因

1. **硬件限制**
   - 不能直接 `mov ds, 立即数`
   - 必须通过通用寄存器中转

2. **统一段基址**
   - 让代码、数据、栈都在同一个段（0x7C00）
   - 避免段错误

3. **确保正确访问**
   - MBR 被加载到 0x7C00
   - 所有段寄存器指向 0x7C00，才能正确访问数据

参见：[[MBR主引导记录]]

## 段的表示方式

### 段:偏移表示法

```
CS:IP    代码段:指令指针
DS:BX    数据段:数据偏移
SS:SP    栈段:栈指针
ES:DI    附加段:目的索引
```

### 物理地址计算示例

```
指令：mov ax, [0x1234]
假设 DS = 0x1000

物理地址 = DS × 16 + 0x1234
         = 0x1000 × 16 + 0x1234
         = 0x10000 + 0x1234
         = 0x11234
```

## 实模式分段的局限性

### 1. 段大小固定

- 每个段最大 64KB
- 对于大程序不方便

### 2. 无内存保护

- 任何段可以访问任何内存
- 程序容易互相破坏

### 3. 地址空间小

- 最多 1MB 内存
- 现代程序远远不够

### 4. 段重叠问题

不同的段基址+偏移可能指向同一物理地址：

```
0x1000:0x0100 = 0x10100
0x1010:0x0000 = 0x10100  (相同的物理地址！)
```

## 保护模式的分段

保护模式下，分段机制大幅增强：

### 段描述符

每个段由 8 字节的段描述符定义：
- **段基址**：32位，可指向任意地址
- **段界限**：20位，段大小
- **权限**：DPL（特权级）
- **类型**：代码段/数据段/系统段

### GDT (全局描述符表)

- 存放所有段描述符的表
- 段寄存器不再直接存基址，而是存**段选择子**
- 段选择子 → GDT → 段描述符 → 段基址

参见：[[段描述符]] [[GDT-GDTR-LGDT]] [[保护模式]]

## 段与页的关系

在保护模式下：

```
逻辑地址 → 分段 → 线性地址 → 分页 → 物理地址
```

1. **分段**：
   - 段选择子 + 偏移 → 线性地址
   - 提供权限控制

2. **分页**：
   - 线性地址 → 页表 → 物理地址
   - 提供虚拟内存

参见：[[段和页]] [[分页机制&PDEPTE]]

## 总结

### 实模式分段

- **目的**：用 16 位寄存器访问 20 位地址空间
- **方法**：段基址×16 + 偏移
- **特点**：简单、直接、无保护
- **限制**：段大小固定 64KB、地址空间 1MB

### 保护模式分段

- **目的**：内存保护、权限控制
- **方法**：段选择子 → 段描述符 → 段基址
- **特点**：灵活、安全、可扩展
- **配合分页**：提供完整的虚拟内存管理

参见：[[实模式]] [[保护模式]] [[段]] [[段寄存器]]

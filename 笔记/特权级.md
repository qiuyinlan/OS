### ① CPL（Current Privilege Level，当前特权级）

- 由 **CPU 的 CS（代码段寄存器）低两位**存储。
    
- 表示 **当前正在执行的程序的特权级**。
    
- 范围：0（最高特权，内核）～3（最低特权，用户程序）。
    
- **作用**：限制当前程序访问某些段或执行特权指令。
    

### ② DPL（Descriptor Privilege Level，段描述符特权级）

- 存储在==段描述符==中。
    
- 表示 **段的访问级别要求**：
    
    - 内核代码/数据通常 DPL=0
        
    - 用户代码/数据通常 DPL=3
        
- **作用**：CPU 检查 CPL 是否满足 DPL 才允许访问该段。
    

### ③ RPL（Requested Privilege Level，请求特权级）

- 存储在 ==**段选择子==（Segment Selector）低两位**。
    
- 用于访问段时“请求特权”，**取 RPL 和 CPL 中的较高值**做访问判断。
    
- 主要用于门（Call Gate）访问和段访问的安全检查。


> 当程序访问段时，==CPU ==会取 **`max(CPL, RPL)`** 来与段的 DPL 比较，决定是否允许访问。

所以在普通情况下，**RPL 和 CPL 一样**，但 RPL 是来自段选择子，而不是自动等于 CPL。

段选择子是去申请访问段的，CPU 根据段选择子找到对应的段描述符，读取段的 DPL、基址、界限等信息。
## 通常情况

（一般情况下是一样的）
- **一般程序访问自己的段时**：
    
    - 用户态程序：CPL=3，RPL=3 → max(3,3)=3 ≤ DPL=3 → 允许访问
        
    - 内核态程序：CPL=0，RPL=0 → max(0,0)=0 ≤ DPL=0 → 允许访问
        
- **特殊情况（调用门、特权转换）**：
    
    - CPL=3，RPL=3，通过 Call Gate 调用内核（DPL=0）
        
        - max(CPL,RPL)=3 > DPL=0 → 允许通过 Call Gate 特权转换，但不能直接访问内核段
            
        - CPU 会执行特权转换，自动切换堆栈和段寄存器
            

---

### 🔹 总结

- CPL = 当前执行程序的真实特权级
    
- RPL = 访问段时声明的请求权限（可以低于 CPL，但不能高于 CPL）
    
- CPU 检查访问时取 **max(CPL,RPL)** 与 DPL 比较
    
- **通常 CPL=RPL，但为了安全设计，==RPL 可以人为降低，提供额外保护**==

# 为什么有四个特权级（0～3）

- **特权级分层**可以提供==多级保护==，==防止低特权代码影响高特权代码。==
    
- 一般用途：
    
    1. **0**：内核态，==完全控制硬件和系统资源==
        
    2. **1、2**：保留，可做设备驱动或系统服务特权层
        
    3. **3**：用户态程序，最受限制，无法直接访问硬件和内核数据
        

> 现实操作系统（Linux、Windows）通常只用 **0 内核** 和 **3 用户** 两层，其余两层保留给特权子系统或未来扩展。

---

### 🔹 总结表

|名称|位置|含义|作用|
|---|---|---|---|
|CPL|CPU CS 低两位|当前运行代码特权级|决定程序当前权限|
|DPL|段描述符中|段访问要求|限制段访问权限|
|RPL|段选择子低两位|请求特权级|调用段时提供安全检查|

- **访问检查**：`max(CPL,RPL) ≤ DPL` → 允许访问
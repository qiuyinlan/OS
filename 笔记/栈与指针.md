（跳转到函数前会先把参数推入当前栈顶，call再把当前地址推进去，之后ret的时候，再弹出来。
函数栈帧只包含 **局部变量 + 保存的寄存器**，**参数（运算的数字，变量值）通常不在局部栈帧里**）
**`call` 指令会把当前（也就是 main 函数中 call 之后）要执行的“下一条指令的地址”压入栈中**，这样函数执行完后，`ret` 就能根据这个地址返回到正确的位置继续执行。
##  esp

`esp` 是英文单词的缩写，全称是：

> **Extended Stack Pointer**

翻译：**扩展的栈指针寄存器**
16位，sp || 32位，esp || 64位，RSP  Register Stack Pointer  “寄存器版”，支持 64 位地址


# 介绍

- ==**栈帧**是 **函数在栈上分配的一块连续内存区域**==
    
- 它包含：
    
    - 函数参数（caller pushed）
        
    - 返回地址（call 指令自动压入）
        
    - 保存的基指针（旧 EBP）
        
    - 局部变量
        

- ==**栈顶（ESP）**：当前**最后压入的元素**所在位置（低地址方向）==
    
- **==栈底（EBP）**：当前函数栈帧的“起点”，相对于栈帧来说靠近高地址==
    
- **栈帧**：从栈底到栈顶的这一块连续空间
    

> 换句话说：
> 
> - 栈帧包括**局部变量、保存的寄存器、参数、返回地址**
>     
> - 栈底 = 栈帧起点（固定，用 EBP 访问局部变量/参数）
>     
> - 栈顶 = ESP（动态，随 push/pop 变化）
>



## 为什么 EBP 固定可以访问局部变量和参数

- 函数开始时：
    

`push ebp        ; 保存调用者 EBP mov  ebp, esp   ; EBP 指向当前栈帧底（保存的 EBP 位置） sub  esp, 8     ; 为局部变量分配空间（x, y）`

- **关键点**：
    
    - `ESP` 会随着 `sub esp, 8`（分配局部变量）而变化
        
    - 但 `EBP` 固定在栈帧底 → 局部变量和参数的偏移不变
        

---

## 3️⃣ 局部变量访问示例

> 减往下，是因为减就是变成低地址，就是往下，没毛病。栈是从高地址到低地址的。

`mov eax, [ebp - 4] ; 访问局部变量 x mov eax, [ebp - 8] ; 访问局部变量 y`

- `[ebp - 4]` = 栈帧基址往下 4 个字节
    
- `[ebp - 8]` = 栈帧基址往下 8 个字节
    

无论函数内部再 push/pop 寄存器，**EBP 都不变**，偏移仍然正确。

---

## 4️⃣ 参数访问示例

`mov eax, [ebp + 4] ; 返回地址（call 自动压入） mov eax, [ebp + 8] ; 参数 a mov eax, [ebp + 12]; 参数 b`

- `[ebp + 4]` 是栈帧上保存的返回地址
    
- `[ebp + 8]` 开始是第一个参数
    
- 偏移固定，不受 ESP 变化影响
    

---

## 5️⃣ 核心理解

1. **EBP = 栈帧固定基址**
    
2. **局部变量 = EBP 的负偏移**
    
3. **参数 = EBP 的正偏移**
    
4. **ESP 动态**，EBP 静态 → 访问安全可靠
    

> 换句话说：  
> **EBP 是“坐标原点”，偏移量告诉 CPU要访问栈帧里的哪块内存**

---


## `[esp]` 才是“栈顶”

栈的内存长这样（地址从上往下变小）👇

```
高地址 ↑
│
│  参数 b = 5        ← [ebp+12]
│  参数 a = 3        ← [ebp+8]
│  返回地址          ← [ebp+4]
│  main 的 ebp（旧基址） ← [ebp]
│  add 的局部变量区
│
└─── esp 指向这里（栈顶，最低地址）
低地址 ↓

```

所以：

- `[esp]` 是栈顶（==最新压入的元素==）；
    
- `[ebp]` 通常指向“旧基址”；
    
- `[ebp+4]`、`[ebp+8]` 是“往高地址方向”偏移去取数据。

# 原理+结合代码

在 C 语言里，不论是主函数 `main()` 还是被调用函数 `add()`，  
它们**其实都==共用同一个栈区==（stack segment）**。


区别是：

- 当 `main` 运行时，它在这个栈的上面一块区域；
    
- 当 `main` 调用 `add` 时，==`add` 又在栈顶上“盖”一层楼；==
    
- 所以每个函数都有**自己独立的一层栈帧（stack frame）**。
**栈帧**是 **函数在栈上分配的一块连续内存区域
（==每当一个函数被调用，系统就在栈上为它划出一块栈帧==，所以，比如要调用add函数，用call add ，进入add后，就划分了一个栈帧。）

假设我们写：

```
int add(int a, int b);
int main() {
    int sum = add(3, 5);
}

```

## esp和ebp
- 当调用 `main()` 时：
    
    - ESP 指向 main 栈帧顶端（栈顶）。
        
    - EBP 指向 main 栈帧底端（栈帧基址）。
        
- 当 `main` 调用 `add()`：
    
    - ESP 会下降，为 `add` 的栈帧分配空间。
        
    - EBP 会更新为 `add` 的栈帧基址（保存旧 EBP 到栈里）。

👉 换句话说：

> 虽然大家都在同一个大栈里，  
> 但每个函数都只看自己那一层（通过 `ebp` 定位）。

---

## 🧠  调用动作（以 CDECL 调用约定为例）

### 压入参数 & call

```
push 5       ; 参数 b
push 3       ; 参数 a
call add     ; 自动压入返回地址

```

栈变化（ESP 指向返回地址）：
汇编编译后（简化）：
```
高地址 ↑
│ 参数 b = 5
│ 参数 a = 3
│ 返回地址（自动压入）
└ esp → 栈顶（返回地址）
ebp → main 栈底

```

### 进入add 函数，建立栈帧

####  EBP 和 ESP 在栈帧建立中的作用

在 x86 常见约定里，建立栈帧通常三步：

```
push ebp        ; 保存调用者 EBP
mov  ebp, esp   ; EBP 指向新栈帧底
sub  esp, N     ; 给局部变量留空间

```
解释：

1. **`push ebp`**
    
    - 把调用者的 EBP 保存起来，保证返回时能恢复。CPU 会把 ==**当前 EBP 的值**==（旧栈帧基址，即 main 栈底）压入栈顶

**EBP 寄存器的值还没有改变**，仍然指向调用者（main 栈帧底）
        
    - 栈顶有了调用者的“楼层底”，新栈帧就可以从这里开始。
        
2. **`mov ebp, esp`**
    
    - 这时 **EBP 才更新**，指向新函数栈帧底（刚压入的 old EBP）
        
    - 这样函数内就可以通过 `[ebp + 偏移]` 访问参数、通过 `[ebp - 偏移]` 访问局部变量。
        
    - **这一步标记了“新栈帧”的开始**。
        
3. **`sub esp, N`**
    
    - ESP 向下移动，给局部变量分配空间。
        
    - 这块区域就属于新栈帧。
        

> 🔹 所以**严格来说**：
> 
> - 栈帧的“建立”并不是单指一个指令，而是通过**保存旧 EBP + 移动 EBP + 调整 ESP**这整个过程形成的。
>     
> - 其中最关键的标志是 **EBP 指向当前函数栈帧底**。


then,执行函数

### 函数执行完毕，准备返回

通常在 C 约定中，返回前要做：

`mov esp, ebp    ; 回收局部变量（ESP 恢复到栈帧底部） 
pop ebp         ; 恢复调用者 EBP（main 的楼层号） ret             ; 弹出返回地址，跳回调用者`

- **`mov esp, ebp`**  
    
    - 把 ESP 回到栈帧底部，释放局部变量占用的栈空间。
        
- **`pop ebp`**
[[0汇编语法#`push` 和 `pop` 的作用]]

    - 弹出 old EBP，恢复调用者栈帧的基址。

- ==弹出 old EBP 的值到 EBP 寄存器==
    
- 此时 **EBP 恢复为调用者栈帧（main）的栈底）**
    
- 栈帧顶部恢复到调用者栈帧的状态
- **`ret`**
    
    - ==弹出返回地址，==跳回 main 函数继续执行。


```
push 5        ; 第二个参数 b
push 3        ; 第一个参数 a
call add      ; 调用函数（CPU自动压入返回地址）
add  esp, 8   ; 调用后清理参数（由调用者完成）
栈顶指针上移 8 字节，清理压入的参数 a、b
```

 这几步说明：

- ✅ 参数确实由调用者（main）压栈；
    
- ✅ 这些参数被压在 **调用者当前的栈空间顶部**；
    
- ✅ 被调函数（add）进入时，直接在这上面建立自己的栈帧。

## 清除参数

在 C 语言默认的调用约定（cdecl）下，  
是**调用者（caller）负责清理参数**的。

也就是说：

> 调用完函数以后，要自己把刚才 `push` 的参数“拿走”。

而清理的方式，不是 `pop` 一次次弹，  
而是直接用一条简单又快的指令：

`add esp, 参数总大小`


> `ebp` 是“栈帧的楼层号”，  
> `旧 ebp` 就是“上一个函数的楼层号”。



==每个函数都住在自己的“楼层”（栈帧）==里，  
进入新函数时要：

1. 把旧楼层号记下来（push ebp）；
    
2. 换一个新的楼层号（mov ebp, esp）。

(别忘了：main函数也是函数！！)

这样：

- 新函数知道自己楼层在哪；
    
- 回去时还能找到原来的楼层。



假设主函数 `main` 调用 `add(3, 5)`：
```
push 5
push 3
call add

```

执行 `call add` 时，CPU 自动把**返回地址**压入栈。  
所以栈长这样👇：

```
高地址 ↑

│ 参数 b = 5         ← [esp+12]
│ 参数 a = 3         ← [esp+8]
│ 返回地址           ← [esp+4]
│ main 的 ebp        ← [esp] ← 现在栈顶！


低地址 ↓

```
这时我们还在 `add` 函数的入口处，  
此时 `ebp` 还是 main 的楼层号。


我们写：

`int add(int a, int b) {     return a + b; }`

编译器生成的汇编（以 `cdecl` 为例）大致如下：

当==执行 `call add`== 时，栈是这样👇：
```
[esp+12] : 参数 b = 5
[esp+8]  : 参数 a = 3
[esp+4]  : 返回地址（call 自动压入）
[esp]    : main 的 ebp（旧基址）


```

也就是说：

- `add` 进入时，`ebp` 还指着 main 的栈帧；
    
- ==参数都已经压好==；
    
- 返回地址是 call 自动压入的。





- 每次 `push` 操作，`esp`（栈顶指针）会减小；
    
- 每次 `pop` 操作，`esp` 会增大。


### 一、先铺垫：分页到底是干嘛的？（快速回顾核心）

分页是操作系统的「内存虚拟化技术」，核心目的是解决==“物理内存碎片” 和 “地址隔离”==（内核空间 / 用户空间分开），本质是做「虚拟地址 ↔ 物理地址」的映射：

- 把「虚拟地址空间」分成固定大小的「虚拟页（比如 4KB）」；
- 把「物理内存」分成同样大小的「物理页框（比如 4KB）」；
- 用「页表 / 页目录」记录两者的映射关系，CPU 访问内存时，会自动通过页表把虚拟地址翻译成物理地址。

之前聊过 32 位二级页表：页目录（4KB）存页表的物理地址，单个页表（4KB）存虚拟页→物理页框的映射，这两个数据结构都要存在物理内存里 —— 而启动分页的关键，就是「让 CPU 知道页目录在哪」，并「开启硬件级的地址翻译」。

### 二、启动分页的完整流程：内核先做什么？再怎么启动？

操作系统启动分页的过程，本质是「从 “直接用物理地址” 过渡到 “用虚拟地址”」的过程，分 3 个核心阶段，每个阶段都有明确的 “内核任务”：

#### 阶段 1：启动分页前 —— 内核在「物理地址模式」下 “打地基”

CPU 刚上电时，处于「实模式」（或叫物理地址模式）—— 此时**分页功能是关闭的**，CPU 发出的地址就是物理地址，不能直接用虚拟地址（因为没有页表做映射）。这一阶段，内核的核心任务是「为启动分页做准备」，具体做 3 件事：

1. **内核自身 “解压缩 + 初始化”**操作系统镜像（比如 Linux 的 vmlinuz、Windows 的 ntoskrnl.exe）启动时，先被加载到物理内存的低地址区（比如 0x100000），内核会先完成自身的初始化：比如初始化内核栈、初始化核心数据结构（比如物理内存管理结构体）、加载必要的驱动（比如内存控制器驱动）。
    
2. **检测物理内存，管理物理页框**内核必须先知道 “电脑有多少物理内存”“哪些物理内存是可用的”—— 通过 BIOS/UEFI 提供的内存检测功能，内核会扫描整个物理内存，把可用的内存按「页框大小（比如 4KB）」划分，建立「物理页框位图」（记录每个页框是否被占用）。这一步是为了==后续分配「页目录、页表」所需的物理页框==（毕竟页目录和页表本身也要存在物理内存里）。
    
3. **建立「临时页表」（关键！）**启动分页的前提是「有页表」，但完整的页表（覆盖内核空间 + 用户空间）太大，启动初期用不上。所以内核会先建一个「临时页表」，只做一件事：==**把内核自身的虚拟地址，一对一映射到对应的物理地址**==。比如内核的虚拟地址 0xC0000000~0xFFFF0000（32 位系统的内核空间），直接映射到物理地址 0x00000000~0x3FFFF000（假设内核实际加载在这个物理地址）。为什么要 “一对一映射”？因为此时内核还在物理地址模式下运行，切换到分页后，==内核的指令和数据地址会变成虚拟地址==，必须通过页表翻译回原来的物理地址，否则 CPU 会找不到内核代码（相当于 “内核自己不能迷路”）。
    
    临时页表的结构很简单（比如 32 位系统下，就是一个简化的二级页表）：
    
    - 页目录：占用 1 个 4KB 页框，里面只有几个有效的页目录项（PDE），只对应内核空间的虚拟地址范围；
    - 每个对应的页表：也占用 1 个 4KB 页框，里面的页表项（PTE）直接指向内核所在的物理页框。

#### 阶段 2：启动分页 —— 通过硬件寄存器 “打开分页开关”

当临时页表建好、页目录的物理地址确定后，内核会通过「CPU 控制寄存器」触发分页功能，这是「硬件层面开启分页」的关键步骤（以 x86 架构为例）：

1. **把页目录的物理地址写入 CR3 寄存器**==CR3 寄存器是 CPU 的 “页目录基址寄存器”==，作用是告诉 CPU：“页目录在物理内存的哪个位置”。内核会找到之前分配给「临时页目录」的物理页框地址（比如 0x00010000），把这个地址写入 CR3—— 这一步让 CPU 知道了 “映射表的入口在哪”。
    
2. **设置 CR0 寄存器的 PG 位（分页使能位）**CR0 寄存器的第 31 位是 PG 位（Page Global Enable），这是 “分页开关”：
    
    - PG=0：分页关闭，CPU 直接使用物理地址；
    - PG=1：分页开启，CPU 会自动把虚拟地址通过页表翻译成物理地址。
    
    内核执行一条指令（比如`mov cr0, eax`，其中 eax 的 PG 位已设为 1），把 CR0 的 PG 位置 1——**这一瞬间，分页功能正式启动！**
    
    注意：此时 CPU 还在执行内核代码，因为临时页表已经把内核的虚拟地址映射到了物理地址，所以地址翻译不会出错，内核代码能无缝继续运行（相当于 “开关一按，立刻生效，且内核不迷路”）。
    

#### 阶段 3：启动分页后 —— 内核==完善==页表，切换到虚拟地址模式

分页开启后，内核的运行模式从「物理地址模式」切换到「虚拟地址模式」（保护模式的一种），之后还要做 2 件关键事，让分页真正能用：

1. **切换到内核的虚拟地址运行**之前内核在物理地址模式下，访问的是物理地址；现在分页开启，内核会把自身的代码、数据、栈的地址，全部切换到「虚拟地址」（比如之前的物理地址 0x00010000，切换到虚拟地址 0xC0010000）—— 因为临时页表已经做好了 “虚拟→物理” 的映射，所以切换后访问完全正常。
    
2. **完善「完整页表」**临时页表只映射了内核空间，现在内核要建立「完整的页表体系」：
    
    - 扩展页目录：把用户空间的虚拟地址范围（比如 32 位系统的 0x00000000~0xBFFFFFFF）对应的页目录项（PDE）补充完整；
    - 为用户空间分配页表：当创建用户进程时，为每个进程分配独立的页表（实现进程地址隔离，每个进程都以为自己独占 4GB 虚拟内存）；
    - 设置内存权限：通过页表项（PTE）的权限位，限制用户空间不能访问内核空间（比如内核空间的 PTE 设为 “只读 + 内核级访问”，用户进程无法修改）。
3. **回收临时页表（可选）**当完整页表建立完成后，临时页表就没用了，内核会释放它占用的物理页框（回收给物理内存池），避免资源浪费。
    

### 三、关键总结：启动分页的核心逻辑

1. 「先物理，后虚拟」：分页启动前，内核必须在物理地址模式下工作 —— 因为没有页表，虚拟地址无法翻译；
2. 「临时页表是过渡」：临时页表只映射内核自身，目的是让内核在开启分页后不 “迷路”；
3. 「硬件是关键」：分页的开启依赖 CPU 的 CR0（PG 位）和 CR3（页目录基址）寄存器，操作系统只是 “配置硬件”；
4. 「内核的前置任务」：核心是 “检测物理内存” 和 “建立临时页表”—— 没有这两步，分页无法启动。
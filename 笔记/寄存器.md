# 寄存器

## 中断
x86 BIOS 中断服务设计的是：

- `AH`：功能号
    
- 其他寄存器（AL、BH、CX、DX）作为参数传入


## 地址

在 x86 实模式（16位）下访问内存，CPU **用“段寄存器:偏移寄存器”**来计算物理地址：

`物理地址 = 段寄存器 × 16 + 偏移寄存器`

- **段寄存器**：CS / DS / ES / SS / FS / GS
    
- **偏移寄存器**：AX / BX / CX / DX / SI / DI / BP / SP / IP 等



### 寄存器记忆口诀（通用）

> 🧠“A算B址C计D指E扩”

| 寄存器         | 常见作用                        | 记忆口诀含义      |
| ----------- | --------------------------- | ----------- |
| **EAX**     | 运算结果、临时值（A：==Accumulator==） | “A算”——主算器   |
| **EBX**     | 数据地址或基址（B：==Base==）         | “B址”——存放地址  |
| **ECX**     | 计数循环（C：Count）               | “C计”——计数器   |
| **EDX**     | 扩展用（D：Data）                 | “D指”——辅助寄存器 |
| **ESI/EDI** | 源/目标索引（用于复制）                | “E扩”——延伸用   |

所以——

> “要循环？用 ECX。要指内存？用 EBX。要写值？用 EAX。”

不是硬性规定，但在 x86 汇编里，确实是传统规定 + 指令限制导致的习惯



所以 **ES:BP** 就是：

- ES（==Extra Segment==，额外段寄存器） → 指明段的起始地址
    
- BP（==Base Pointer==） → 段内偏移
    
- CPU 访问 `[ES:BP]` 时，会算出完整的物理地址。


# BP
## BP 的主要用途

1. **在栈帧中访问局部变量和函数参数**（最经典用途）
    
    - 当函数被调用时，通常会：
        
        `push bp       ; 保存原来的 BP mov bp, sp    ; 新 BP 指向当前栈顶 → 建立栈帧`
        
    - 之后访问参数：`[bp+4]`、局部变量：`[bp-2]`。
        
    - 这个机制就是 x86 的“标准栈帧”方法。
        
2. **实模式中也可以临时当作普通寄存器使用**
    
    - 例如书里第四章的：
        
        `mov bp, loadermsg`
        
        这里 BP 只是用来存储字符串的偏移地址（实模式下 ES:BP 指向显存或内存缓冲区），**并没有当作栈帧基址**。

## 和 SP 的区别

|寄存器|用途|
|---|---|
|SP|栈顶指针（push/pop 自动用）|
|BP|栈帧基址 / 一般指针（访问函数参数或内存地址）|

> 简单说：SP 是“栈顶”，==BP 是“指针，可以指向栈或者其他地方”==。





# 栈与指针

[[栈与指针]]


# AL

看到l和h,不要当成陌生的寄存器呀！！他们就是高八位低八位而已！！！


- AL 是 **AX 寄存器的低 8 位**
    
- AX 是 16 位寄存器，可以拆成：
    
    `AX = 高 8 位 AH + 低 8 位 AL`


## 小结

|寄存器|位数|用途|
|---|---|---|
|AX|16|累加器，16 位运算 & BIOS/DOS 参数|
|AH|8|AX 高 8 位，功能号或高字节操作|
|AL|8|AX 低 8 位，单字节运算、字符、I/O 数据、子功能号|

💡 **记住口诀**：

- **AL** → 低 8 位，小量数据、字符、子功能
    
- **AH** → 高 8 位，功能号/状态
    
- **AX** → 16 位大寄存器，综合用途

## AL 的用途

1. **算术运算（8 位）**
    
    - 加法、减法、乘法、除法可以用 AL 处理单字节数据
        
    - 例如：
        
        `mov al, 5 add al, 3  ; AL = 8`
        
2. **中断调用参数**
    
    - BIOS 或 DOS 中断常用 AX 传参

==你写 or al, 0x02 开启 A20==：

- 这也是 **把 AL 的某一位作为控制参数**，传给端口 0x92
    
- 只不过这一次 AL 存的是 **硬件控制信息**，而不是字符或数字



    - 很多功能只需要 8 位参数时，就用 AL
        
    - 例子：你的 `int 0x10`：
        
        `mov ax, 0x1301`
        
        - AH = 0x13 → 功能号（打印字符串）
            
        - AL = 0x01 → 子功能或标志（显示方式）
            
3. **I/O 操作**
    
    - IN/OUT 指令读写端口时，AL 常用来存放 8 位数据
        
    - 例如读键盘或显卡数据
        
4. **字符处理**
    
    - AL 常用来存储 ASCII 字符
        
    - 例如打印字符、比较字符、转换大小写



# CR家族

## 控制寄存器家族

| 名称      | 全称                 | 作用简述                      |
| ------- | ------------------ | ------------------------- |
| **CR0** | Control Register 0 | ==开启/关闭保护模式==、分页、协处理器等    |
| **CR1** | （保留）               | 没有使用                      |
| **CR2** | Control Register 2 | 记录导致页错误的虚拟地址              |
| **CR3** | Control Register 3 | ==保存页目录的物理地址==（分页机制的根）    |
| **CR4** | Control Register 4 | 启用各种CPU扩展功能（PSE、PAE、SSE等） |
| **CR8** | Control Register 8 | 控制中断优先级（x86-64 才有）        |


## 1️⃣ 内核主要用C语言

- 内核的大部分功能都用 **C语言实现**，例如：
    
    - 内存管理、页表操作
        
    - 进程调度
        
    - 文件系统
        
    - 系统调用逻辑
        
- 书中指出：
    
    > “系统本身大部分是 C 语言实现的，而且并不需要多么高深的算法及数据结构功底。”
    
- **原因**：
    
    - 可读性强、便于维护
        
    - 可移植性好（不同CPU架构仅需修改少量硬件相关代码）
        
    - 与现代编译器配合，可生成高效机器码
        

---

## 2️⃣ 汇编语言的使用场景

- 汇编语言用于==**与硬件直接交互或特权操作**==，例如：
    
    - CPU初始化（如实模式切换到保护模式）
        
    - 异常/中断处理
        
    - 上下文切换、寄存器保存恢复
        
    - 系统调用接口（直接发中断）
        
- 书中指出：
    
    > “在内核文件中，有些比较长的汇编代码不适合用内联汇编完成，还是需要专门写汇编文件专项专用。”
    
- 汇编主要用于**关键底层操作或C语言无法精确控制的场景**
    

---

## 3️⃣ C与汇编混合编程方式

书中提到两种主要方式：

1. **独立汇编文件 + 独立C文件**
    
    - 分别编译为目标文件，再链接生成可执行内核
        
    - 用于比较长的汇编例程或关键启动代码
        
2. **内联汇编**
    
    - 在C代码中嵌入少量汇编指令
        
    - 用于小段底层操作或优化
        
    - 书中还详细介绍了基本内联汇编和扩展内联汇编


# 汇编具体

## 1️⃣ 启动代码（Boot Loader）

- **阶段**：开机之后，CPU在实模式下执行。
    
- **任务**：
    
    - 初始化CPU寄存器、段寄存器
        
    - 设置堆栈
        
    - 切换到保护模式（x86）
        
    - 加载操作系统内核到内存
        
- **为什么用汇编**：
    
    - C语言需要运行时环境（栈、段寄存器初始化等），而启动时这些还没准备好。
        
- **位置**：一般是`boot.S`或类似文件
    

---

## 2️⃣ 中断/异常处理程序

- **任务**：
    
    - 保存现场（寄存器内容）
        
    - 调用C语言编写的中断处理函数
        
    - 恢复现场，返回
        
- **为什么用汇编**：
    
    - 中断触发时CPU状态需要精确控制
        
    - 必须直接访问寄存器
        
- **位置**：如`irq.S`、`trap.S`
    

---

## 3️⃣ 上下文切换（进程切换）

- **任务**：
    
    - 保存当前进程寄存器到PCB
        
    - 加载下一个进程寄存器
        
- **为什么用汇编**：
    
    - CPU寄存器的保存和恢复必须精确
        
    - 速度要求高
        
- **位置**：一般少量汇编嵌入在C函数中
    

---

## 4️⃣ 系统调用接口

- **任务**：
    
    - 从用户态切换到内核态
        
    - 调用内核函数
        
    - 返回用户态
        
- **为什么用汇编**：
    
    - 需要设置特权级转换和栈切换
        
- **位置**：如`swi.S`、`syscall.S`
    

---

## 5️⃣ 硬件相关操作

- 例如：
    
    - CPU控制寄存器（CR0/CR3等）
        
    - IO端口操作
        
    - TLB刷新
        
- **为什么用汇编**：
    
    - C语言无法直接访问特定寄存器或执行CPU指令
        

---

### ✅ 总结

- **汇编语言的典型用途**：
    
    1. 启动 Loader
        
    2. 中断/异常处理
        
    3. 上下文切换
        
    4. 系统调用接口
        
    5. 硬件直接操作
        
- **C语言主要负责**：
    
    - 内存管理、文件系统、进程调度、驱动逻辑等大部分逻辑


# 不用c的原因


## 1️⃣ C语言的局限性

虽然C语言可以生成高效代码，但它本质上是**高级语言**：

1. **抽象了硬件细节**
    
    - ==C语言只提供变量、指针、函数等抽象概念，不直接控制CPU寄存器、段寄存器、栈指针或控制寄存器。
        ==
    - 例如：你想直接设置CR0寄存器开启分页，用C写是做不到的，C语法里没有“CR0 = …”的语句。
        
2. **需要运行时环境**
    
    - C语言代码依赖堆栈、全局变量初始化、函数调用约定。
        
    - 但操作系统启动阶段、异常处理或上下文切换时，这些运行时环境还没准备好，C语言无法直接执行。
        
3. **无法精确控制指令执行顺序和CPU状态**
    
    - 特权操作往往要求严格顺序和精确控制寄存器和标志位。
        
    - C编译器可能会为了优化改变指令顺序，这在底层操作中可能会出错。
        

---

## 2️⃣ 汇编语言的优势

- **直接访问硬件**
    
    - CPU寄存器、端口、特权寄存器都可以直接操作
        
    - 可以执行CPU特权指令（如切换到保护模式、TLB刷新、I/O操作）
        
- **控制精确**
    
    - 汇编语言允许精确控制指令顺序
        
    - 能保存和恢复寄存器、切换栈等操作完全可控
        
- **不依赖运行时环境**
    
    - 启动阶段或异常处理中不需要C语言的运行时支持
        
    - 可以直接执行，保证内核启动和中断处理可靠
        

---

## 3️⃣ 举几个例子

|场景|为什么必须用汇编|
|---|---|
|CPU从实模式切换到保护模式|需要直接操作CR0寄存器和段寄存器，C无法写CR0 = …|
|中断处理|保存和恢复所有寄存器状态，精确控制栈，C做不到|
|上下文切换|精确保存当前寄存器到PCB，加载新寄存器，C语言不能保证指令顺序|
|I/O端口操作|需要 `in`/`out` 指令直接与硬件通信，C无法直接执行|

---

## 4️⃣ 总结理解

> **为什么用汇编而不用C**  
> 因为这些操作：
> 
> 1. 需要直接访问CPU寄存器或特权寄存器
>     
> 2. 需要精确控制指令顺序
>     
> 3. 可能发生在C语言运行时环境还没准备好的阶段
>     
> 
> C语言做不到这些，而汇编可以精确完成，所以汇编用于低级硬件操作和特权操作。
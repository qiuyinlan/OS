## 1️⃣ 取指令（Fetch）

- **做什么**：CPU 从内存中取出下一条要执行的指令。
    
- **细节**：
    
    - 内存地址由 **程序计数器（PC 或 IP 寄存器）** 指定。

>pc

### x86 架构实现

- **实模式（16 位）**
    
    - 没有单独叫 PC 的寄存器。
        
    - 用 **CS（代码段寄存器）+ IP（指令指针寄存器）** 来实现 PC 功能。
        
    - ==逻辑地址 = CS × 16 + IP==
        
- **保护模式（32 位）**
    
    - 用 **CS:EIP** 来实现 PC
        
    - 32 位 EIP 存偏移，CS 存段选择子
        

> 所以在 x86 上，PC 是“抽象概念”，但由寄存器（CS+IP/EIP）具体实现。


    - 取到指令后，PC 会更新到下一条指令的地址（顺序执行时+指令长度）。
        
- **类比**：像老师把一道题目拿给你做，你先“取到题”。
    

---

## 2️⃣ 译码（Decode）

- **做什么**：CPU 分析取来的指令，==确定它要做什么操作==。
    
- **细节**：
    
    - 确认操作类型：加法、减法、跳转、加载、存储……
        
    - 确认操作数来源：寄存器、立即数、内存地址。
        
    - 准备所需的内部控制信号，让执行单元知道怎么做。
        
- **类比**：看题后理解题意，决定用哪种方法解题。
    

---

## 3️⃣ 执行（Execute）

- **做什么**：CPU 执行指令指定的操作。
    
- **细节**：
    
    - 算术逻辑单元（ALU）进行计算。
        
    - 跳转指令计算目标地址。
        
    - 比较指令产生条件码（比如标志寄存器的零/符号标志）。
        
- **类比**：真正做题，把数字加起来或者判断哪个选项正确。
    

---

## 4️⃣ 访问内存（Memory）

- **做什么**：==对于需要读/写内存的指令==，CPU 访问内存。
    
- **细节**：
    
    - **加载指令（load）**：从内存读数据到寄存器。
        
    - **存储指令（store）**：把寄存器数据写入内存。
        
    - 对寄存器操作的指令可能跳过此阶段。
        
- **类比**：需要翻书找答案或者把答案写回作业本。
    

---

## 5️⃣ 写回寄存器（Write Back）

- **做什么**：把执行或内存访问得到的结果写回寄存器，完成指令执行。
    
- **细节**：
    
    - 所有计算结果、加载的内存数据都要写回寄存器。
        
    - 更新标志寄存器（条件码）也可能在这个阶段。
        
- **类比**：把做好的答案写到答题卡上，记录完成。
    

---

### 💡 特点

- **流水线**：每个阶段可以同时处理不同指令，像流水线工厂一样提高效率。
    
- **乱序执行**：如果某些阶段的资源空闲，CPU 可以提前执行其他独立指令。
    
- **分支预测**：提前取指令阶段猜测下一条跳转指令，可能错了需要清空流水线。
位图就是——  
**用一串 0 和 1 表示大量==资源的占用情况**==。

- **0** 代表：这个资源是 **空闲** 的
    
- **1** 代表：这个资源是 **已占用** 的
    

就这么简单！

---

# 🌟 为什么叫“位图”？

因为它本质就是==一堆 “bit（位）” 拼成的一张“图”==。

比如有 8 个物理页：

`物理页号:   0 1 2 3 4 5 6 7 位图（bit）: 1 0 1 1 0 0 1 0`

意思是：

- 页 0 → 已占用
    
- 页 1 → 空闲
    
- 页 2 → 已占用
    
- 页 3 → 已占用
    
- 页 4 → 空闲
    
- ……
    

---

# 🌟 位图的用途是什么？（特别特别重要）

位图通常用来管理：

- **物理内存页**（内存管理最常用）
    
- 文件系统的**磁盘块**
    
- 进程或线程的 **PID 分配表**
    
- 内核对象 ID（句柄表）
    

但在操作系统里，它最常用来表示：

> **哪些物理内存页已经被占用，哪些还可以用**

所以位图就像：

🌟 **“内存占用地图”**

---

# 🌟 为什么操作系统喜欢用位图？

原因非常非常关键，下次面试别人问，你一定能答出来：

### **1. 超省空间（几乎不占内存）**

如果有 1024 个物理页：

- 位图需要 1024 bit
    
- 就是 1024 / 8 = **128 字节**
    

比你发两句微信还省！

---

### **2. 查找空闲页特别快**

只要从前往后扫描 bit：

- 找到第一个 0 → 就是空闲页
    
- 找到 1 → 已占用
    

速度快到爆。

---

### **3. 回收也很快**

回收就是——  
把对应 bit 设置回 0。

比如释放物理页号 5：

`位图[5] = 0;`

一条位运算就搞定。

---

# 🌟 位图的底层存储是什么？

位图底层就是：

==`一个数组==（uint8_t / char 数组）`

因为一个字节有 8 个 bit：

- 1 字节 → 管 8 个页
    
- 1 KB → 管 8 * 1024 = 8192 个页
    

特别省！

---

# 🌟 位图和链表比较（你能立即懂它的意义）

|方式|查找空闲|空间占用|是否适合大规模资源|
|---|---|---|---|
|链表|慢|大|不适合|
|数组|中等|较大|一般|
|**位图**|**非常快**|**非常小**|**最适合**|

所以 OS 管理成千上万的物理页，不可能一个个用链表；  
必须用位图！



# 位图适合什么？什么时候不能用位图？

### **位图只适合管理：**

- **数量巨大**
    
- **资源大小完全一样**
    
- **只能区分“占用/空闲”两种状态**
    

比如：

- 物理页（4KB 一页）
    
- PID
    
- 文件系统的块（block）
    

**因为这些东西只需要一个 bit 表示状态，且它们都是“固定大小资源”。**

---

# 🚫 位图不适合的情况（很关键）

当资源是这种情况时，位图就没法用了：

### **1. 资源大小不相同**

比如 malloc 的堆管理时：

- 有人要 8 字节
    
- 有人要 128 字节
    
- 有人要 1KB
    
- 有人要 40 字节
    

你没办法用“1 bit = 一个固定块”来表示，因为资源大小不是固定的。

### **2. 资源数量不是特别大**

比如进程控制块 PCB 或线程 TCB：

- 可能就几十个、几百个，不会有十几万那么多
    
- 没必要用位图，用链表/数组反而更清晰
    

### **3. 资源有复杂属性，不是能用“0/1”描述的**

比如：

- CPU 运行队列（每个进程有优先级、状态、剩余时间片）
    
- 文件系统的目录项（名字、类型、位置等）
    

这些东西远远不止“空闲/占用”两种状态，一个 bit 根本不够。

### **4. 需要频繁插入/删除，位置灵活**

链表可以 O(1) 插删，位图不行。

---
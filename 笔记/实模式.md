# 实模式

[[CPU执行指令]] [[内存分段机制]] [[寄存器]] [[保护模式]]

## 什么是实模式

**实模式 (Real Mode)** 是 CPU 的"原始工作状态"，核心特点是**直接访问物理内存、无内存保护、地址空间有限**。

- **出现时间**：8086 CPU 时代
- **地址总线**：20 位（可访问 1MB 内存）
- **寄存器**：16 位
- **特点**：简单、直接、无保护

## 实模式的由来

### 历史背景

- 8086 CPU 寄存器只有 **16 位**
- 一个 16 位寄存器最多只能表示 64KB（2^16）
- 但物理地址总线是 **20 位**，理论上能访问 **1MB** 内存（2^20）

### 解决方案：分段机制

为了用 16 位寄存器访问 20 位地址空间，Intel 发明了**内存分段**：

```
物理地址 = 段寄存器 × 16 + 偏移地址
```

参见：[[内存分段机制]]

## 实模式特点

### 1. 段寄存器 + 偏移量寻址

| 段寄存器 | 名称 | 用途 |
|---------|------|------|
| **CS** | Code Segment | 代码段 |
| **DS** | Data Segment | 数据段 |
| **SS** | Stack Segment | 栈段 |
| **ES** | Extra Segment | 附加段 |

地址计算：
```
物理地址 = 段基址 << 4 + 偏移
         = 段基址 × 16 + 偏移
```

#### 示例

```
CS = 0x1000
IP = 0x0010
物理地址 = 0x1000 × 16 + 0x0010 = 0x10010
```

### 2. 没有内存保护

- 程序可以随意访问任意物理内存
- 多个程序同时运行容易冲突
- 一个程序崩溃可能影响整个系统

### 3. 所有地址都是物理地址

- 程序看到的地址几乎就是物理内存地址
- 没有虚拟内存的概念

### 4. 硬件简单

- CPU 不做复杂的地址转换
- 只需简单的"段基址×16+偏移"运算

## 实模式下的内存布局

| 地址范围 | 大小 | 用途 |
|---------|------|------|
| 0x00000 - 0x003FF | 1KB | 中断向量表 (IVT) |
| 0x00400 - 0x004FF | 256B | BIOS 数据区 |
| 0x00500 - 0x07BFF | ~30KB | 可用区域 |
| 0x07C00 - 0x07DFF | 512B | MBR 加载区 |
| 0x07E00 - 0x9FFFF | ~608KB | 可用内存 |
| 0xA0000 - 0xBFFFF | 128KB | 显存 |
| 0xC0000 - 0xFFFFF | 256KB | BIOS ROM |

## 高端内存回卷

在实模式下，地址超过 1MB 会发生"回卷"：

```
段地址 = 0xFFFF
偏移   = 0xFFFF
物理地址 = 0xFFFF × 16 + 0xFFFF = 0x10FFEF
```

但地址总线只有 20 位，最高位会被截断：
```
0x10FFEF → 0x0FFEF（回卷到低地址）
```

## 实模式 vs 保护模式

| 特性 | 实模式 | 保护模式 |
|-----|-------|---------|
| CPU位数 | 16位 | 32位/64位 |
| 内存寻址 | 1MB | 4GB 或更多 |
| 内存保护 | 无 | 有（段/页权限） |
| 地址类型 | 物理地址 | 虚拟地址 |
| 多任务 | 不支持 | 支持 |
| 使用场景 | DOS、BIOS | 现代操作系统 |

参见：[[保护模式]]

## 实模式的使用场景

### 1. 开机启动阶段（BIOS）

- CPU 上电默认在实模式下运行
- BIOS 使用实模式初始化硬件
- MBR 和早期 bootloader 在实模式下执行

### 2. 兼容老程序

- DOS 程序
- 老旧游戏
- 某些嵌入式程序

### 3. 低级硬件操作

- MBR、GRUB 第一阶段
- 直接访问物理硬件、硬盘、显存

## 为什么实模式依然存在？

即便现代 CPU 支持保护模式和长模式，实模式仍然在使用：

### 1. 简单、直接、兼容性强

- 实模式可以直接用 20 位物理地址（1MB 内存）
- 不需要页表或段选择器
- 兼容老程序、BIOS、MBR

### 2. 硬件初始化方便

- 实模式下 CPU 不做保护，也没有复杂的分页机制
- 硬件厂商早期提供的例程都是实模式

### 3. 保护模式启动需要实模式

- x86 CPU 上电默认实模式
- 想进入保护模式，需要先从实模式切换（设置 GDT、CR0 寄存器等）

参见：[[0启动流程]] [[段描述符]] [[GDT-GDTR-LGDT]]

## 实模式下的分段机制

### 内存分区 vs 内存分段

- **内存分区**：操作系统层面的概念（代码区、数据区、堆、栈）
- **内存分段**：CPU 硬件层面的访问方式（段寄存器×16+偏移）

两者是**不同层级上的"划分"**：
- 分段：物理访问层面（CPU 如何计算地址）
- 分区：逻辑管理层面（不同数据放哪一块）

### 段的大小

- 实模式下，每个段的长度固定为 **64KB**（对应 16 位偏移寄存器）
- 段直接对应物理内存

参见：[[内存分段机制]] [[段]]

## 实模式下 CPU 工作原理

CPU 的任务就是**执行指令**：

1. **取指令 (Fetch)**：从 CS:IP 读取指令
2. **译码 (Decode)**：解析指令含义
3. **执行 (Execute)**：执行运算
4. **写回 (Write Back)**：写回结果

CPU 的三大部分：
- **控制单元**：控制指令执行流程
- **运算单元**：进行算术和逻辑运算
- **存储单元**：寄存器，临时存储数据

参见：[[CPU执行指令]] [[寄存器]]

## 总结

实模式的核心特点：

1. **简单直接**：段基址×16+偏移 = 物理地址
2. **无保护**：可以随意访问任何内存
3. **地址空间小**：只能访问 1MB 内存
4. **兼容性好**：CPU 上电默认实模式

学习角度：
- **8086/实模式** → 理解分段和地址计算
- **现代操作系统** → 理解保护模式 + 虚拟内存 + 页表

参见：[[保护模式]] [[BIOS]] [[MBR主引导记录]]

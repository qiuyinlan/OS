`libc` 是 **“C library”** 的简写，也就是==**C 语言标准库**==。

- `lib` → library（库）
    
- `c` → C 语言

它依赖操作系统**，所以不同系统有不同的 libc，或者根本没有。
在裸机或嵌入式系统（没有完整操作系统）上，通常没有 libc，或者只有最小化实现：

- 只能做纯算法或内存操作的函数。
    
- 不能依赖文件、进程、设备等系统调用。

# libc构成

### 1️⃣ 纯库函数（不依赖系统调用）

- 这些函数完全在用户态执行，不需要内核参与。
    
- 例子：
    
    - 字符串操作：`strlen()`, `strcpy()`, `strcmp()`
        
    - 数学运算：`abs()`, `pow()`, `sqrt()`
        
    - 内存操作：`memcpy()`, `memset()`
        
- 特点：执行速度快，不会发生特权级切换（不触发 `int 0x80`）。
    

---

### 2️⃣ 封装系统调用的函数

- 这些函数需要内核提供服务，所以会调用系统调用接口。
    
- 例子：
    
    - 文件操作：`open()`, `read()`, `write()`, `close()`
        
    - 进程管理：`fork()`, `execve()`, `getpid()`
        
    - 内存分配底层：`brk()`, `mmap()`
        
- 特点：
    
    - 用户态调用 libc 函数 → libc 设置参数 → `int 0x80` → 内核执行 → 返回结果。
        
    - libc 只负责封装和参数处理，真正操作资源的是内核。
        

---

### 3️⃣ 用户态优化函数（部分系统调用 + 缓存）

- 有些函数内部可能先做用户态处理，只有必要时才调用系统调用。
    
- 例子：
    
    - `printf()`：先在用户态缓存输出缓冲区，满了或调用 `fflush()` 时才触发 `write()` 系统调用。
        
    - `malloc()`：在用户态先从内存池分配，内存池耗尽时才调用 `brk()` 或 `mmap()` 扩展内存。

## libc 实际上是一个“编译好的文件”

当你==安装了 GCC 或 Clang，它们会顺带安装 C 标准库==。  
这个库以两种形式存在：

| 类型  | 文件后缀                  | 作用             |     |
| --- | --------------------- | -------------- | --- |
| 静态库 | `.a` （archive）        | 在编译时直接打包进可执行文件 |     |
| 动态库 | `.so` （shared object） | ==程序运行时由系统加载== |     |

在 Linux 系统上，这两个文件一般位于：

`/usr/lib/libc.so /usr/lib/x86_64-linux-gnu/libc.so.6 /usr/lib32/libc.so.6`

你可以在终端输入：

`ls /usr/lib | grep libc`

或者：

`ldd /bin/ls`

你会看到：

`libc.so.6 => /usr/lib/x86_64-linux-gnu/libc.so.6`

这表示命令 `ls`（系统程序）在运行时依赖了 `libc.so.6`。

---

## ⚙️ 三、谁提供这个库？

不同系统有不同实现：

|系统|libc 实现|
|---|---|
|Linux|glibc（GNU C Library）|
|macOS|Apple libc（基于 FreeBSD）|
|Android|bionic libc|
|Windows|msvcrt.dll（Microsoft C Runtime）|

所以当你写 C 程序用 `printf()`，真正被执行的，是 glibc 里对应的函数。

---

## 💻 四、gcc 编译时怎么找到它

当你执行：

`gcc main.c -o main`

gcc 自动做三件事：

1. 编译 `main.c` → 生成目标文件 `main.o`
    
2. 查找你用到的函数，比如 `printf`
    
3. 链接 `/usr/lib/libc.so` 里的实现代码进可执行文件
    

你可以用命令看得很清楚：

`gcc main.c -o main -v`

它会显示链接阶段中：

`/usr/lib/gcc/x86_64-linux-gnu/... -lc`

这里的 `-lc` 就是告诉链接器去找 **libc**。

---

## 🧠 五、那内核为什么不用它？

因为==内核启动时还没有文件系统==，也就没有 `/usr/lib` 这些路径；  
所以它==不能去加载 `libc.so`==。  
这就是为什么操作系统内核要自己写 `printk()`、`memcpy()`、`strcpy()` 等函数——  
这些都是在重建“自己的 libc”。

tip：
==**文件系统不是开机就有的，是“内核启动到一定阶段后由内核自己初始化出来的”。**

启动流程是分层的。  
**文件系统处在非常靠后的位置。**
 OS 真正“拥有文件系统”？要经历下面步骤：
 
[[文件系统加载]]



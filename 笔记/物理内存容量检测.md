[[获取内存以及代码讲解]]
在实模式或保护模式下，**CPU 自己其实“看不出”有多少物理内存**。  
因为——

> 内存条只是硬件，CPU 没有办法直接数一数“我有多少条、每条多大”。

所以，CPU 或操作系统必须 **通过某种方法“探测”物理内存容量”**。

### 保护模式下为什么要知道内存大小

因为保护模式下：

- 系统要建立 **段表（GDT）**、**页表（Page Table）**；
    
- 要为内核、用户进程、堆、栈等分配空间；
    
- 如果不知道内存上限，可能会访问到不存在的地址 → 报错。
    

所以，在进入保护模式（或进入内核）前，操作系统必须检测出内存容量。


### 检测内存的方式（BIOS 提供）

在刚开机时，CPU 仍然运行在实模式，可以通过 **BIOS 中断（int 15h）** 获取内存信息。  
BIOS 在底层替你“探测内存硬件”，然后通过中断返回结果。

常见的 3 种方法（从新到旧）：

| 中断号                     | 子功能                | 返回信息            | 特点      |
| ----------------------- | ------------------ | --------------- | ------- |
| `int 0x15, ax = 0xe820` | 获取完整内存映射表（推荐）      | 可返回所有可用和保留的内存区域 | 最准确、最现代 |
| `int 0x15, ax = 0xe801` | 获取扩展内存信息           | 适用于老系统          |         |
| `int 0x15, ah = 0x88`   | 仅返回 ==1MB ==以上内存大小 | 最古老、信息最少        |         |

比如操作系统启动时会：

1. 暂时进入实模式；
    
2. 调用 `int 15h, ax=E820h`；
    
3. BIOS 返回内存分布表（哪些区域可用、哪些保留）；
    
4. ==OS 把这份信息保存下来==；
    
5. 切换到保护模式后就知道整个内存的范围了。


## 中断服务细讲

## 🧠 背景知识

- 这些都是 BIOS 的 **INT 15h** 中断的子功能。
    
- BIOS 中断号 `INT 0x15` 属于 **系统服务中断**，用于提供硬件信息，比如内存、键盘控制器、ACPI 等。
    
- 操作系统在启动时调用这些服务来获得 **物理内存分布表**。
    

---

## 1️⃣ `INT 15h, AX = 0xE820` —— 最完整、现代的方式（现代操作系统都用它）

### 📘 功能

获取==**系统物理内存映射表==（System Memory Map）**。  

它在**映射（描述）物理地址空间 → 内存用途**。
它本质上是一张 **地图（表格）**，描述 你电脑的“物理内存空间”里
哪些区域  
是 **可用** 的？  
哪些是 **不可用** 的？  
哪些被 **BIOS/设备/硬件** 占用？

返回的信息包括：==哪些区域可以使用，哪些保留给 BIOS、设备或内核。==

### 📥 调用方式

|寄存器|含义|
|---|---|
|AX = 0xE820|指定功能号|
|EDX = 0x534D4150 ('SMAP')|魔数标识，表明调用者理解此接口|
|ES:DI|指向接收结构体的缓冲区|
|ECX|缓冲区大小（一般 20 字节）|
|EBX|输入 0 表示第一次调用；返回值非 0 表示还有下一个内存区域（循环调用）|

### 📤 返回信息（存入 ES:DI 指向的结构体中）：

| 字段                         | 含义                       |
| -------------------------- | ------------------------ |
| BaseAddrLow / BaseAddrHigh | 内存区域起始地址                 |
| LengthLow / LengthHigh     | 区域长度                     |
| Type                       | 类型：1=可用内存，2=保留区，3=ACPI 等 |
| ACPI 属性                    | （某些 BIOS 支持）             |
|                            |                          |

> ✅ 优点：信息最详细，可返回所有内存段。  
> 🧠 用法：Linux、Windows、现代引导程序（如 GRUB）都使用此方法。

---

## 2️⃣ `INT 15h, AX = 0xE801` —— 兼容旧机器

### 📘 功能

返回 1MB 以上的扩展内存信息。

### 📥 调用方式

- AX = 0xE801
    
- BIOS 返回：
    
    - AX = 1MB ~ 16MB 的 KB 数
        
    - BX = 16MB 以上的 64KB 块数
        

> ⚠️ ==只能告诉你大概有多少内存，**无法区分哪些区域是保留的**。  ==
> 主要用于早期 486、Pentium 机型。

- 它只能返回总容量；
    
- 它没法告诉你 “哪些区域是保留给 BIOS 的、哪些能用”；
    
- 所以操作系统还得自己假定某些内存区域不能碰（比如 640KB~1MB 之间的保留区）。
    

**但对于早期 OS（比如 DOS 扩展内核、早期 Windows 95、Minix 等）来说，已经够用了**，  
因为它们没有复杂的内存映射管理，只要知道“我有多少可用 RAM”就能跑。

---
后来为什么被 E820 替代？

因为：

- E801 不能报告保留区域；
    
- E801 不能支持 4GB 以上的系统；
    
- 于是 BIOS 后来引入了 **E820**，能返回完整的内存映射表，精确到每个地址段。
    

> E820 可以告诉你：  
> “00000000~0009FFFF 可用，00100000~BFFFFFFF 可用，C0000000~FFFFFFFF 保留给设备。”



---

## 3️⃣ `INT 15h, AH = 0x88` —— 最古老的方式

### 📘 功能

返回 **1MB 以上的扩展内存容量**（单位 KB）。

### 📥 调用方式

- AH = 0x88
    
- BIOS 返回：AX = 可用扩展内存（KB）
    

> ⚠️ 只能返回最大 64MB 的容量，而且**不区分内存类型**。  
> 适用于非常老的 DOS 系统或 8086/80286 时代。

---

## 🧩 总结对比

| 接口         | 出现年代           | 能干啥                       | 限制                |
| ---------- | -------------- | ------------------------- | ----------------- |
| 0x88       | 286~386        | 返回 1MB 以上扩展内存大小           | 只能返回最多 64MB       |
| **0xE801** | 486~早期 Pentium | 返回 1MB~16MB + 16MB 以上内存总量 | 不能报告保留区，==只能算总量== |
| 0xE820     | Pentium II 以后  | 返回完整内存映射表，全部内存区域及类型       | 现代标准              |



---

💡 **一句话记忆：**

> `E820` 全面精准，现代系统必用；  
> `E801` 过渡时代备用；  
> `88` 史前遗留，只能查个大概。


### 实战操作--代码

### 第一步：调用 BIOS 中断 `int 0x15, ax=0xe820`

这是最推荐、最精确的方式（现代 BIOS 都支持）。  
BIOS 会返回一张 **内存映射表（Memory Map）**，告诉你：

|字段|含义|
|---|---|
|BaseAddr|区域起始地址（64位）|
|Length|区域长度（64位）|
|Type|类型（1=可用内存，2=保留，3=ACPI等）|

### 第二步：用汇编写一个循环，反复调用 BIOS

因为 BIOS ==一次只返回一段内存信息==，需要多次调用==直到 EBX=0 为止==。

伪代码：

`mov eax, 0xE820 mov edx, 0x534D4150       ; 'SMAP' 标志 mov ecx, 20               ; 缓冲区长度 xor ebx, ebx              ; 第一次调用 EBX=0 int 0x15 ; BIOS 把结果写到 ES:DI 所指的内存结构里 ; 如果 CF=0，说明成功 ; EBX != 0 说明还有下一条记录`

循环调用，直到 EBX 返回 0，表示内存表遍历完。

[[获取内存以及代码讲解]]



---

### 第三步：保存返回结果（内存表）

每次 `int 0x15` 返回的数据结构（20字节）都要保存下来，最终形成一个列表。

内存表样例（书中类似）：

|起始地址|长度|类型|
|---|---|---|
|0x00000000|0x0009FC00|可用内存|
|0x0009FC00|0x00000400|BIOS 数据区|
|0x00100000|0x1FF00000|可用内存|
|0x1FF00000|0x00100000|保留|

---

### 第四步：计算“可用物理内存总量”

只加上 **Type=1（可用）** 的区域长度。  
例如：

`0x0009FC00 + 0x1FF00000 = 0x1FF9FC00 ≈ 511MB`

→ 表示物理内存大约为 512MB。

---

### 第五步：打印结果验证（用显示函数）

书里 loader 会用 `put_str` 或 `put_int` 打印出内存大小，比如：

`put_str "total memory: " put_int mem_total`

显示结果类似：

`total memory: 0x1FF9FC00`

这说明检测成功。

---

## ✅ 总结成一句话：

> **实战检测物理内存大小的过程**就是：  
> 1️⃣ 在实模式调用 BIOS `int 0x15, ax=0xE820`  
> 2️⃣ 循环读取所有内存段信息  
> 3️⃣ 保存结果到缓冲区  
> 4️⃣ 汇总 Type=1 的区域长度  
> 5️⃣ 输出总内存大小

---

💡 类比理解：  
你（loader）是操作系统的“侦察兵”，  
在进入保护模式（上战场）前，得先问 BIOS（指挥官）：“地图上哪些地方是安全的？”  
BIOS 就一段一段告诉你，把这些安全区域都记录下来，  
然后你再根据这些记录建立页表、规划内核空间。


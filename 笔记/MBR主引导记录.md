# MBR主引导记录

[[0启动流程]] [[硬盘]] [[Loader加载器]] [[NASM汇编器]]

## 什么是 MBR

**MBR (Master Boot Record, 主引导记录)** 是硬盘最开头的一段关键数据区域，是计算机从"硬件初始化"（BIOS 阶段）过渡到"加载操作系统"的核心桥梁。

- **位置**：硬盘的第 0 扇区（Sector 0）
- **大小**：固定 512 字节
- **特征**：最后两个字节必须是 `0x55AA`（魔数，用于 BIOS 验证）

## MBR 结构（512 字节）

| 部分 | 大小 | 内容 |
|------|------|------|
| 引导代码 | 前 446 字节 | 启动代码，负责加载下一阶段 |
| 分区表 | 64 字节 | 4 个分区表项，每项 16 字节 |
| 魔数 | 2 字节 | `0x55AA` - BIOS 启动检测标志 |

### 分区表结构

每个分区表项 16 字节：
- 引导标志（1字节）：0x80 表示活动分区
- 起始 CHS 地址（3字节）
- 分区类型（1字节）
- 结束 CHS 地址（3字节）
- 起始 LBA 地址（4字节）
- 分区扇区数（4字节）

## MBR 的作用

### 1. 引导操作系统

- BIOS 将 MBR 加载到内存 `0x7C00` 地址
- MBR 检查分区表，找到活动（可启动）分区
- 加载该分区的引导扇区或 [[Loader加载器]]

### 2. 接力棒作用

MBR 太小（只有 512 字节），无法直接加载完整操作系统：

```
BIOS → MBR (512B) → Loader → 操作系统内核
```

- **MBR**：找到 loader、跳转
- **Loader**：真正加载内核

## 编写 MBR 示例

### MBR 基本功能

1. 初始化段寄存器：`ds, es, fs, gs, ss`
2. 初始化栈指针：`sp`
3. 清屏：使用 BIOS 中断 `int 0x10`
4. 打印字符串
5. 死循环：`jmp $`

### 关键代码结构

```nasm
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00

    ; ... 你的代码 ...

    times 510-($-$$) db 0    ; 填充到510字节
    db 0x55, 0xaa             ; 魔数
```

#### 关键点说明

- `vstart=0x7c00`：告诉 [[NASM汇编器]] 代码将被加载到此地址
- `times 510-($-$$) db 0`：用 0 填充到 510 字节
  - `$`：当前地址
  - `$$`：当前 section 起始地址
  - `$-$$`：已用字节数
- `db 0x55, 0xaa`：MBR 签名（必须！）

### 为什么需要初始化段寄存器？

```nasm
mov ax, cs
mov ds, ax
mov es, ax
mov ss, ax
```

- **硬件限制**：不能直接 `mov ds, 立即数`
- **统一段基址**：让代码、数据、栈都在同一个段内（0x7C00）
- **避免段错误**：确保所有段寄存器指向 MBR 所在段

## 将 MBR 写入硬盘

使用 `dd` 命令将编译好的 MBR 写入虚拟硬盘：

```bash
nasm -o mbr.bin mbr.asm
dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
```

### dd 命令参数

| 参数 | 作用 |
|------|------|
| `if=mbr.bin` | 输入文件（input file）|
| `of=hd60M.img` | 输出文件（硬盘镜像）|
| `bs=512` | 块大小（block size）= 1 扇区 |
| `count=1` | 只拷贝 1 个块 |
| `conv=notrunc` | 不截断输出文件，只覆盖指定部分 |

## MBR 读取硬盘示例

MBR 需要从硬盘读取 [[Loader加载器]]：

### rd_disk_m_16 函数流程

1. **传参数**：
   - `eax` → loader 起始扇区（如 0x2）
   - `bx` → loader 在内存中的地址（如 0x900）
   - `cx` → 需要读多少扇区

2. **告诉硬盘要读多少扇区**：写到端口 0x1F2

3. **写 LBA 地址**到硬盘寄存器：
   - 0x1F3 (LBA low)
   - 0x1F4 (LBA mid)
   - 0x1F5 (LBA high)
   - 0x1F6 (device)

4. **发送读命令**：向 0x1F7 写入 0x20

5. **等待硬盘准备好**：检查 status 寄存器

6. **读数据到内存**：每次读 2 字节

7. **跳转到 loader**：`jmp 0x900`

参见：[[硬盘]] [[CHSLBA]] [[端口与INOUT指令]]

## 注意事项

### MBR 用完就可以被覆盖

- MBR 加载 loader 后，控制权就交出去了
- MBR 的代码不再需要，内存可以被复用
- 这就是为什么 MBR 可以放在 0x7C00（较低地址）

### BIOS 为什么只能加载 512 字节？

1. **历史原因**：BIOS 很古老，只提供最基本服务
2. **兼容性**：不同操作系统、不同磁盘格式都不一样
3. **统一接口**：
   - BIOS → MBR (固定512B)
   - MBR → Loader (位置可变)
   - Loader → 内核

参见：[[0启动流程]] [[实模式]]

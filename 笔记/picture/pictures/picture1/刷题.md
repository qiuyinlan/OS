栈（**Stack**）是一种**后进先出（LIFO, Last In First Out）**的数据结构，就像堆盘子，最后放进去的盘子总是最先被拿出来。

---

### 栈的基本操作

1. **初始化栈**：创建一个空栈。
2. **压栈（Push）**：将元素添加到栈的顶部。
3. **弹栈（Pop）**：从栈的顶部取出元素。
4. **读取栈顶元素（Peek/Top）**：获取栈顶元素的值，但不移除它。
5. **判断栈是否为空**：检查栈是否为空。

例如：

- **操作顺序：**
    
    css
    
    复制代码
    
    `初始化：空栈 [] 压栈 1：栈 [1] 压栈 2：栈 [1, 2] 弹栈：栈 [1]`
    

---

### 栈与波兰表达式的关系

**波兰表达式（前缀表达式）**是一种不需要括号的算术表达式。我们通过**栈**来处理其运算：

1. **数字（操作数）入栈**： 遇到数字时，将数字压入栈。
2. **运算符出栈计算**： 遇到运算符时，从栈中弹出两个数字，进行计算，将计算结果压回栈。

#### 示例

表达式：`* + 2 3 4`  
（等价于普通表达式：`(2 + 3) * 4`）

- 步骤：
    1. 遇到 `*`，跳过，继续。
    2. 遇到 `+`，跳过，继续。
    3. 遇到 `2`，压栈：栈为 `[2]`。
    4. 遇到 `3`，压栈：栈为 `[2, 3]`。
    5. 遇到 `+`，弹出 `3` 和 `2`，计算 `2 + 3 = 5`，结果压栈：栈为 `[5]`。
    6. 遇到 `4`，压栈：栈为 `[5, 4]`。
    7. 遇到 `*`，弹出 `4` 和 `5`，计算 `5 * 4 = 20`，结果压栈：栈为 `[20]`。


> 波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。

### Input

输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。

### Output

输出为一行，表达式的值。  
可直接用printf("%f\n", v)输出表达式的值v。

# 栈
### 栈的基本概念

栈是一种 **后进先出 (LIFO, Last In First Out)** 的数据结构。栈可以主动存储任意数据，而不仅限于编译器在调用函数时自动存储的临时变量。

### 栈的两种用途

1. **系统栈（程序调用栈）**
    
    - 这是编译器和操作系统自动管理的栈，主要用于存储函数调用时的临时变量、返回地址、函数参数等。
    - 程序员通常不会直接操作这个栈。
2. **用户栈（程序员定义的栈）**
    
    - 程序员可以定义自己的栈，存储自定义数据，如临时计算结果、中间状态等。
    - 常见实现方法是用数组或链表手动构建栈，并通过 `push` 和 `pop` 操作主动管理。
- 用户栈（即程序中通过数据结构模拟的栈）通常是用来模拟系统栈功能的一种结构。它虽然模仿了系统栈的某些特性，但本质上是人为构建的，与真正的系统栈（由硬件和操作系统支持的栈内存）是分开的。

### 1. **用户栈与系统栈的差别**

- **用户栈（模拟栈）**：
    
    - 是由程序员通过数据结构（如数组、链表等）实现的。
    - 模拟了栈的“后进先出”（LIFO）特性。
    - 存储在堆区或全局区，与系统栈的管理无关。
    - 用于应用层逻辑，比如处理递归、表达式计算、括号匹配等问题。
- **系统栈**：
    
    - 是由 CPU 和操作系统管理的，用于函数调用、返回地址保存、本地变量存储等。
    - 存储在内存中的栈区，地址一般从高向低增长。
    - 是程序运行时的必需部分，直接与硬件指令相关。

### 主动存储数据的场景

在程序中主动使用栈存储数据，是为了方便后续的有序访问和处理。以下是一些典型场景：

1. **表达式求值（如波兰表达式）**
    - 通过栈存储操作数和中间结果，按照操作符的优先级顺序进行计算。
2. **括号匹配**
    - 用栈存储未匹配的左括号，当右括号出现时进行匹配。
3. **深度优先搜索（DFS）**
    - 用栈代替递归函数中的隐式调用栈，记录需要访问的节点。
4. **撤销操作（如编辑器）**
    - 将操作步骤存入栈中，当需要撤销时从栈中弹出最近的操作。
5. **历史记录**
    - 例如浏览器的前进/后退功能，使用两个栈分别记录访问的页面和后退的历史。


### **堆区 vs 栈区**

- **栈区**：按照后进先出的规则管理内存，通常用于局部变量、函数调用等。
- **堆区**：更灵活，分配和释放的顺序不受限制，适合需要长期保存的数据。

### 3. **堆的管理**

堆的管理由操作系统和运行时库负责，它采用**自由存储链表**或其他内存分配算法（如伙伴系统）来管理内存块。堆分配的内存块之间可能存在空闲碎片。
## 什么是地址？

内存可以想象成一排整齐排列的格子：

`┌────────────┐ ← 高地址（大的数） │  单元 n-1  │ │  单元 n-2  │ │  ……        │ │  单元 1    │ │  单元 0    │ ← 低地址（小的数） └────────────┘`

每个格子都有一个「编号」，这个编号就是它的**地址**（Address）。

- 0 号格子的地址是 `0x00000000`
    
- 1 号格子的地址是 `0x00000001`
    
- 依此类推...
    

📘 所以：  
👉 **“低地址” = 数值小的地址**  
👉 **“高地址” = 数值大的地址**




## 不同结构的增长方向

在内存中，不同的东西（代码、数据、栈）增长方向不一样。

|区域|说明|增长方向|
|---|---|---|
|**代码段**|程序指令存放处|从低地址往高地址增长|
|**数据段 / 堆**|存放全局变量、动态内存|从低地址往高地址增长|
|**栈（Stack）**|存放局部变量、函数返回地址|🚨 从高地址往低地址增长！|



## 为什么栈从高地址往低地址增长？

有两个原因：

1. **历史设计**  
    早期计算机系统的内存布局是固定分区的：
    
    - 程序和数据从低地址开始；
        
    - 栈放在高地址，往下长；  
        → ==这样它们就不会互相覆盖。==
        
2. **方便检测溢出**  
    因为栈顶（`ESP`）从高往低移动，系统能轻松判断栈有没有“撞”到堆。

# 大小端序

## 什么是端序（Endian）

端序（Endianness）指的是：

> **多字节数据（比如 int、float）在内存中是怎么按顺序存放的。**

一个字节放8bit

### 小端序（Little Endian）

> 低地址存**低位字节**


### 大端序（Big Endian）

> 低地址存**高位字节**

一些网络协议、老式 CPU（如 Motorola、SPARC）使用 **大端序**。
网络上传输的字节序是统一规定的——  
👉 **网络字节序（Network Byte Order）= 大端序**

比如一个 32 位整数：

`0x12345678   （十六进制表示，等于十进制的 305419896）`

它有 4 个字节：

|字节序号|内容|
|---|---|
|byte3|0x12|
|byte2|0x34|
|byte1|0x56|
|byte0|0x78|

## 两种存储方式对比

| 内存地址 | 小端序（Little Endian） | 大端序（Big Endian） |
| ---- | ------------------ | --------------- |
| 0x00 | 0x78               | 0x12            |
| 0x01 | 0x56               | 0x34            |
| 0x02 | 0x34               | 0x56            |
| 0x03 | 0x12               | 0x78            |

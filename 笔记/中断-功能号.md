在 x86 BIOS 调用中（像你刚刚贴的 `int 0x10`），**流程就是这样：**

1. **中断号决定调用哪个 BIOS 功能**  （功能号）
    
    - `int 0x10` → 视频服务
        
2. **AH（高 8 位）填功能号**
    
    - 告诉 BIOS 你想干什么，比如：
        
        - 0x00：设置视频模式
            
        - 0x06：滚屏 / 清屏
            
        - 0x0E：Tty 打印字符
            
3. **其他寄存器填参数**
    
    - AL、BH、CH、CL、DH、DL 等 → 各种功能的参数
        
    - 你刚刚的例子：
        
        `AL = 滚动行数 BH = 属性（颜色） CH/CL = 左上角行列 DH/DL = 右下角行列`
        
    - BIOS 根据这些参数执行对应操作
        
4. **执行中断**
    
    `int 0x10`
    
    → CPU 跳到 BIOS 内部，把寄存器里的参数读进去执行功能
    

所以可以总结成一句话：

> **“中断号选择服务，AH 指功能号，其他寄存器填参数，int 调用执行。”**



## 什么是「功能号」？（EAX = 0xE820）

BIOS 里有很多中断服务，比如：

| ===中断号===  | 功能        | 举例           |
| ---------- | --------- | ------------ |
| `int 0x10` | ==显示器==服务 | 打印字符、设置光标位置  |
| `int 0x13` | ==磁盘==服务  | 读写磁盘扇区       |
| `int 0x15` | 系统服务      | 包括内存检测、电源管理等 |

🧠 所以：

- `int 0x15` 是“系统服务”这个大类；
    
- 而“功能号”就是这个大类里的==具体子功能==。
    

👉 举例：

| EAX    | 功能描述              |
| ------ | ----------------- |
| 0x88   | 获取扩展内存大小（1MB以上部分） |
| 0xE801 | 获取扩展内存信息（早期接口）    |
| 0xE820 | 获取完整内存映射（最先进的接口）  |
[[物理内存容量检测]]


> 所以：  
> `mov eax, 0xE820` 就是告诉 BIOS——  
> “我想调用 int 15h 的 E820 子功能，请返回内存映射表。”

---


# int

## 什么是 `int` 指令？

- `int` 全称是 **Interrupt**（中断）
    
- 它是 x86 CPU 的一条 **指令**，用来触发 **软中断**（软件中断）
    
- 语法：
    
    `int <中断号>`
    
    比如：
    
    `int 0x10`
    
    → 调用 **中断号 0x10** 对应的中断处理程序（这里是 BIOS 视频服务）
    

---

## 2️⃣ `int` 是怎么“执行”的

当 CPU 遇到 `int n` 时，会做这些步骤：

1. **保存现场**
    
    - CPU 会把当前 **CS、IP、FLAGS** 压栈
        
    - 这样中断结束后能回来继续执行原来的程序
        
2. **查找中断向量表**
    
    - x86 内存最前面的 1024 字节保存了 **中断向量表（IVT）**
        
    - 每个中断号占 4 字节，保存 **段地址:偏移地址**
        
    - CPU 会用 `n` 查找对应的地址
        
3. **跳转执行中断处理程序**
    
    - CPU 跳到 IVT 指向的内存地址
        
    - 执行该中断处理程序里的指令
        
    - 你在 BIOS 中看到的各种功能就是这些程序
        
4. **返回原程序**
    
    - 中断处理完后执行 `iret`（Interrupt Return）
        
    - CPU 弹栈恢复 CS、IP、FLAGS
        
    - 原来的程序继续执行
(选择：来找段描述符的，然后来确定地址的，所以是选择，选择描述符～～～)
段选择子（Segment Selector）是一个**16位的数值**，存放在段寄存器里，比如：

- CS（代码段选择子）
    
- DS（数据段选择子）
    
- SS（栈段选择子）
    
- ES/FS/GS（额外段选择子）
    

也就是说，**每一个段寄存器里存的其实不是“段地址”，而是一个选择子。**

- **选择子只是个“引用”**（告诉CPU去哪看）
描述符才是“被引用的内容”，==所以选择子16位就够了==。


## 选择子内部的结构

选择子长 16 位，但这 16 位是分段使用的👇

| 位数   | 名称                                   | 含义                      |
| ---- | ------------------------------------ | ----------------------- |
| 15-3 | **索引值（Index）**                       | 指向 GDT/LDT 中的==第几个==描述符 |
| 2    | ==**TI（Table Indicator）**==（表指示符）    | 指示是使用==GDT 还是 LDT==     |
| 1-0  | **==RPL==（Request Privilege Level）** | ==请求特权级==（表示当前程序的权限级别）  |
`b` 是**二进制标记**，用来告诉汇编器这是个二进制数，最右边是第0位

## 工作原理（流程理解）

1️⃣ 程序访问某段内存时，比如执行一条指令要访问数据段。  
2️⃣ CPU 读取 DS 寄存器中的值（即段选择子）。  
3️⃣ 解析选择子里的：

- **TI**：判断是从 GDT 还是 LDT 取。
    
- **Index**：确定在==表==中的哪一项。  
    4️⃣ 取出对应的**段描述符**（里面有段基址、界限、权限）。  
    5️⃣ 将描述符缓存到 CPU 内部的==**段描述符缓存寄存器**==中。  即将段基址、段界限、访问权限等信息加载到 CPU 内部缓存（段寄存器缓冲区）。
    6️⃣ CPU 根据描述符的内容进行访问控制和地址计算。


> ⚠️ 注意：**仅 mov 段寄存器不会刷新流水线**，所以修改段寄存器后通常需要用远跳转刷新（Far Jump）。


# index

编程语言里整数默认至少 16 位，当你写：

`0x0001  ; 数值 1`

- 这个 0x0001 本身是一个 **16 位的数字**
    
- **但是在段选择子里，它只会放到高 13 位**（所以左移 3 位）
    

所以你看到的 16 位，只是数字的表示范围，并不是 Index 在段选择子里实际占用的位数。

所以相关代码，要将index左移
```
SELECTOR_CODE  equ (0x0001<<3) + TI_GDT + RPL0
```

左移 3 位：

`Index << 3 = 0000 0000 0000 1000`

- 低 3 位 = 000 → 正确的 TI=0, RPL=0
    
- 高 13 位 = 0000 0000 0001 → Index=1 ✅

**左移确实让数值变大呀，为什么访问段的时候不受影响？** 这里要弄清楚一个核心概念：**段选择子里的“数值”并不是段基址，它只是一个索引和标记**。

CPU 并不是直接把段选择子当作物理地址，它会 **解析段选择子**：

1. 取高 13 位 → 得到 Index → 找到 GDT 第几个描述符
    
2. 取第 2 位 → TI → 选择 GDT 或 LDT
    
3. 取低 2 位 → RPL → 权限
    

> 段选择子本身的数值大小没有直接对应内存地址，它只是告诉 CPU “去 GDT/LDT 的第几个段描述符”。

（==只是你用外界的十六进制眼光看，它数值上变大了而已，实际上，看选择字看的就是13位位基准）
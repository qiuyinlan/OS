在内核、编译器、汇编器之间，要达成一个“共识”：

> 当我调用一个函数时，参数该谁压栈？谁负责清理？返回值放哪？

## 一、什么是调用约定？

就是：**主调函数（caller）和被调函数（callee）之间如何约定“参数怎么传、栈谁清理”的规则。**


---

## 二、常见调用约定的几种形式（x86）

|名称|参数传递方向|谁清理栈|用途|
|---|---|---|---|
|`cdecl`|从右到左压栈|调用者清理栈|C 语言默认约定|
|`stdcall`|从右到左压栈|被调函数清理栈|Windows API 用|
|`fastcall`|部分参数放寄存器|被调函数清理栈|高效调用|
|`sysv`|Linux 下通用约定|调用者清理栈|Linux 内核用|

书里重点讲两个：
### ⭐ stdcall

- 参数从 **右向左入栈**
    
- **被调用者**（callee）清栈
    
- Windows API 常用
    
- 但==不能支持可变参数==
### ⭐ cdecl（内核最重要的约定）

- 参数从 **右向左入栈**
    
- **调用者（caller）清栈**
    
- ==支持可变==参数（printf 就靠它）
    

**所以 OS 内核用 cdecl 是必然的**：  
👉 内核要写 printf、各种 debug 输出、设备驱动，必须靠可变参数。


## 三、C 语言函数在底层的样子

[[栈与指针#结合代码]]


内核中 C 与汇编的混合编程之所以能协作，是因为它们遵循**相同的调用约定（SysV ABI）**，通过**栈帧结构对齐参数与返回地址**实现函数级互操作；  
而当用户态进入内核态时，则由**系统调用入口的汇编桥接代码**将寄存器参数转换为 C 函数能理解的栈格式，从而打通两个世界。

- 在 32 位 x86 平台上，  
    **`sysv` ≈ `cdecl`**（几乎一模一样）
    
- 只是名字不一样：
    
    - Windows 世界称它 `cdecl`
        
    - Linux 世界称它 `System V ABI`
        

---
# 那为什么内核说自己用 “sysv”？

因为 Linux 是从 UNIX（System V）系发展来的，  
它遵循 **System V ABI 文档** 中定义的调用约定。  
而这个约定就是“C 语言风格”的那套，也就是原来的 `cdecl`。

# c与内核的调用

### ➤ 比如 C 里写：

```c
put_char('A');
```

cdecl 规则下，调用时栈长这样：

```
[esp]      返回地址（call 自动压入）
[esp+4]    参数 'A'
```

所以汇编里取参数必须写：

```asm
mov ecx, [esp + 4]
```

### 关键点

- **不能直接 mov ecx, [esp]**，因为那是返回地址
    
- **参数永远从 esp+4 开始**
    
- 多个参数就是 esp+8、esp+12……
    
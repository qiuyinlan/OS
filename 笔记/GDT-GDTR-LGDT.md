# GDT

## 第 0 项是空描述符
CPU 需要一种办法来表示：

> “我现在这个段寄存器（CS、DS、SS...）里面是空的，没有指向任何有效段。”

就像变量初始化之前是 `NULL` 一样。  
于是他们规定：

> ✳️ 如果段寄存器中的选择子 = 0（即 index=0），  
> 那么这意味着“该段不存在”。

那 CPU 就会去看 GDT 
为了防止它误以为“存在”，Intel 就规定：

> **GDT 的第 0 项必须是空描述符（全 0）**。

## GDT构成

## CPU 对 GDT 的要求

1. **必须有的段**
    
    - **第 0 项**：空描述符（CPU 要求，选择子为 0 时无效）
        
    - **代码段**（Code Segment）
        
    - **数据段**（Data Segment）
        

> 这三个段在保护模式下基本必备，否则程序无法执行或访问数据。

2. **可选段**
    
    - 栈段（Stack Segment）
        
    - 显存段（Video Memory Segment）
        
    - 系统段（TSS、LDT、任务段）
        
    - 各种特定功能段（比如段基址不在 0、分开内核/用户段）
        

---

## 🧩 二、为什么不同项目顺序不同？

### 1️⃣ 顺序 **不影响功能，只要选择子正确**

GDT 是一个数组，每个段对应一个索引：

`段选择子 = 索引 × 8 + RPL`

比如：

- 索引 1 → 选择子 = 0x08
    
- 索引 2 → 选择子 = 0x10
    

CPU 不在乎哪个段在第 1 个、哪个在第 2 个，  
只要程序在 `CS`、`DS`、`SS`、`ES` 等寄存器里 **加载正确的段选择子** 就行。

---

### 2️⃣ 项目设计习惯不同

- **小型实验/OS 教学项目**：
    
    - 常常把顺序写成 `[空, 数据, 代码, 栈]`
        
- **真实操作系统或更复杂项目**：
    
    - 可能把内核代码段放在第 1 个，用户代码段放在第 2 个，数据段分内核/用户两套
        
    - 方便管理权限和特权级
        

> 也就是说，段顺序是 **人为安排的**，不是 CPU 强制规定的。

---

### 3️⃣ 还可能因为**额外段**导致顺序不同

- 显存段、任务状态段（TSS）、用户段、LDT …
    
- 每个项目需要的段不同，顺序自然不同
    
- 关键是：程序加载时选择子要对应 GDT 的索引
    

---

## 🧠 三、总结

|原因|解释|
|---|---|
|必备段|空描述符、代码段、数据段|
|可选段|栈段、显存段、用户段、系统段等|
|顺序不同|CPU 不在乎，只要选择子正确；项目根据权限管理、可读性和设计习惯安排顺序|
|索引对应选择子|选择子 = GDT 索引 × 8 + RPL|

> ⚡ 核心理解：**GDT 的顺序可以随意，但段选择子一定要指向你想用的段**。

==所以，段选择子要自己定义。==
# **LGDT（Load GDT Register）指令**  

==跟硬件有关==

👉 是用来**加载 GDTR** 的指令，也就是把你写好的 GDT 的位置和大小告诉 CPU。

语法：

`lgdt [gdt_descriptor]`

`gdt_descriptor` 是一个 6 字节的内存结构：

|偏移|大小|含义|
|---|---|---|
|0|2 字节|GDT 的长度 - 1|
|2|4 字节|GDT 的基址|

举个例子：
```
gdt_descriptor:
    dw gdt_end - gdt_start - 1   ; limit
    dd gdt_start                 ; base

```

这段结构告诉 CPU：

> “GDT 从 gdt_start 开始，到 gdt_end 结束。”

然后执行：

`lgdt [gdt_descriptor]`

==CPU 就会把 `gdt_start` 和 `gdt_end - gdt_start - 1` 这两个值装进 GDTR。==


**LGDT（Load GDT Register）指令**  
👉 是用来**加载 GDTR** 的指令，也就是把你写好的 GDT 的位置和大小告诉 CPU。

语法：

`lgdt [gdt_descriptor]`

`gdt_descriptor` 是一个 6 字节的内存结构：

|偏移|大小|含义|
|---|---|---|
|0|2 字节|GDT 的长度 - 1|
|2|4 字节|GDT 的基址|

举个例子：

`gdt_descriptor:     dw gdt_end - gdt_start - 1   ; limit     dd gdt_start                 ; base`

这段结构告诉 CPU：

> “GDT 从 gdt_start 开始，到 gdt_end 结束。”

然后执行：

`lgdt [gdt_descriptor]`

CPU 就会把 `gdt_start` 和 `gdt_end - gdt_start - 1` 这两个值装进 GDTR。


# **GDTR（Global Descriptor Table Register）**  
👉 是一个==**48 位寄存器**==，专门用来**告诉 CPU：GDT（全局描述符表）在内存中的位置和大小**。
GDTR 寄存器保存 GDT 的起始地址和界限，它占 6 个字节：前 2 字节是 limit，后 4 字节是 base。
它有两个部分

| 位数         | 含义                            |
| ---------- | ----------------------------- |
| **低 16 位** | GDT 的界限（Limit）—— GDT 的长度减 1   |
| **高 32 位** | GDT 的基址（Base）—— GDT 在内存中的起始地址 |
LIMIT界限——==范围==
base——基址

### 为什么 limit 是“长度减一”？

因为 GDT 的索引从 0 开始，比如：
在硬件层面上，**CPU 的设计天然就是数组索引从 0 开始的**。不过第0项无效。
- 第一项偏移 0；
    
- 最后一项偏移 limit。
    

所以为了方便 CPU 检查越界，只要看“偏移量 ≤ limit”就行。


也就是说，GDTR 就像是：

> “指针 + 长度”，指明 GDT 在哪里、占多大空间。

CPU 每次访问段描述符（比如你访问内存、加载段寄存器）时，  
都要根据 GDTR 的内容找到 GDT。



### 缺页异常


当进程访问某个虚拟地址时，如果该虚拟页还没有对应的物理页，就会触发 **缺页异常**。这是操作系统按需分配物理内存的关键机制。 流程：

1. **CPU 查询页表**
    
    - CPU 访问虚拟地址时，首先通过 **MMU（内存管理单元）** 查页表。
    - 页表中记录虚拟页对应的物理页框信息以及访问权限。
    - 如果页表条目的 ==**Present 位** 为 0，表示该虚拟页当前没有映射到物理页==。
    - 这时，CPU 会立即触发 **缺页异常中断**，暂停当前指令执行，并转入内核异常处理程序。
2. **内核判断访问是否合法**
    
    - 内核根据当前进程的虚拟内存布局判断访问是否有效。
    - **合法访问**：
        - 访问地址在进程合法的虚拟内存范围内（如堆、栈）。
        - 内核会为该虚拟页分配空闲的物理页框，并将页表条目更新为新的物理页映射，同时设置访问权限和状态标志。
    - **非法访问**：
        - 访问地址不在进程允许的虚拟内存范围内（如访问空指针或越界地址）。
        - 内核会触发 **Segmentation Fault（段错误）**，通常导致进程被终止。
3. **物理页分配与页表更新**
    
    - 内核从空闲物理页池中选择一页或多页物理内存（页框）进行分配。
    - 内核将新分配的物理页号写入页表条目，并将 Present 位置 1，同时设置访问权限（可读/可写/可执行）和状态位。
4. **程序继续执行**
    
    - 更新完页表后，CPU 会重新执行刚才触发异常的指令。
    - 后续访问该页不再触发缺页异常。

> 注意：==**物理内存大多数是在缺页时分配**==。  
> 这就是==按需分配==的核心思想：**虚拟地址空间可以先保留，而物理页只有在实际访问时才分配，提高内存利用效率。**



### 总结

- Linux 使用 **分页机制** 将虚拟内存映射到物理内存
- **页** 是内存管理的最小单位，提供隔离、按需分配和碎片控制
- **页表** 记录虚拟页与物理页的映射，并管理权限
- **多级页表** 节省内存开销，支持稀疏分配
- **缺页异常** 是物理页分配的触发机制
- **按需分配** 让虚拟内存空间可以远大于物理内存，提高系统效率和灵活性


## malloc 与虚拟内存、物理内存的关系


在 C 语言中，malloc 是动态内存分配的标准函数。它允许程序在运行时请求一块指定大小的内存。然而，malloc 并不直接分配物理内存，==它只涉及虚拟内存的管理==。

当你写：

```c
p = malloc(2025);
```

malloc 的处理流程： ==1.检查堆空间是否足够==

- 如果堆中已有空闲块，malloc 直接返回该地址 注意：这时并不涉及物理内存，只是虚拟地址空间的分配 2.堆空间不足时，向内核申请虚拟地址
- malloc 调用系统调用 brk（调整程序堆末尾地址），==内核为程序分配一段新的虚拟地址区域==

注意：`malloc` 并不会分配物理内存。

### 🔹 什么时候分配物理内存？

==访问的时候才触发！！==
当你 **第一次访问** 这片区域：

```c
p[0] = 2025;
```

发生了以下过程：

1.触发缺页异常

- CPU 查询页表时发现对应的虚拟页没有物理页映射
- 因此触发 缺页中断，让操作系统介入

2.内核分配物理页

- 内核从空闲物理页池中分配一页或多页物理内存

3.建立虚拟页 → 物理页映射

- 内核更新进程的页表
- 虚拟地址和实际物理页之间建立映射
- 后续访问这段内存直接命中页表，无需再触发缺页异常，表本身也储在主内存

4.完成访问

- 程序继续执行
- malloc 返回的虚拟地址现在对应实际物理内存

这种按需分配机制使得程序可以申请大块虚拟内存，而物理内存只在实际访问时使用，大大提高了内存利用率。

---

## 整体流程图
```
malloc(size)
    ↓
检查堆中是否有空闲块
    ↓
如果堆足够 → 返回虚拟地址（物理内存未分配）
    ↓
如果堆不足 → 向内核申请虚拟地址
    ↓
分配到虚拟地址空间（仍然没有物理页）
    ↓
程序第一次访问虚拟地址
    ↓
CPU 查页表 → 触发缺页异常
    ↓
内核分配物理页
    ↓
更新页表，建立虚拟页 → 物理页映射
    ↓
程序继续执行，访问命中页表
    ↓
后续访问直接使用物理页，无需再次触发缺页异常
```

通过这个流程可以看到，malloc、虚拟内存和物理内存实际上是三个不同的层次：

- malloc 负责 虚拟地址分配
- 虚拟内存负责 地址映射、隔离与安全
- 物理内存负责 真实存储数据

---

## 分享总结

- 程序看到的是 **虚拟内存**，而不直接操作物理内存
- 虚拟内存让程序觉得有 **连续、安全、超大空间**
- 内核通过 **页 + 页表** 来管理虚拟页到物理页的映射
- **物理内存** 只有在程序第一次访问该虚拟地址时才分配（触发缺页异常）
- 多级页表和按需分配减少内存开销，提高物理内存利用率
- `malloc` 只分配 **虚拟内存地址空间**，不分配物理内存
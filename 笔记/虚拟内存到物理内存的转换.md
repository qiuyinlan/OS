# 原始只有一级页表时流程
## 转换流程

假设使用**分页机制**（常见于现代CPU）：

### 步骤 1：虚拟地址拆分

- 一个虚拟地址通常拆成：
    
    1. **虚拟页号（VPN, Virtual Page Number）**
        
        - 用来索引页表
            
    2. **页内偏移（Page Offset）**
        
        - 这个偏移在页内不变，直接加到物理页框的起始地址上即可。
            

例如：

`虚拟地址：0x1234ABCD 虚拟页号：0x1234A 页内偏移：0xBCD`

---

### 步骤 2：TLB查找

1. CPU先去**TLB**查虚拟页号：
    
    - **命中**：直接得到物理页框号 → 拼接页内偏移 → 得到物理地址 → 访问内存
        
    - **未命中**：进入下一步
        

---

### 步骤 3：页表查找

1. MMU访问**页表**（在主存里）：
    
    - 根据虚拟页号找到对应的物理页框号（PFN, Physical Frame Number）
        
    - 如果页表中没有该映射 → 触发**缺页异常（Page Fault）** → 操作系统加载页到物理内存

补充：没映射的情况

(1) 页从未分配

- 虚拟地址对应的页还没有被操作系统分配物理内存。
    
- 例子：
    
    - ==程序刚刚开始运行==，堆或栈增长到新的虚拟页
        
    - 程序引用一个全局数组，但操作系统还没给这个虚拟页分配物理内存
        
- 这种情况下，页表条目通常是**无效位（Present bit = 0）**，表示没有映射。
    
 (2) 页被换出（Swapped Out）

- 操作系统可能为了腾出内存，==把不活跃的页写入**磁盘的交换空间==（swap space）**。
    
- 页表条目仍然存在，但标记为“无效/在磁盘上”，MMU找不到有效物理页框。
    
- 访问这个虚拟页时会触发缺页异常 → 操作系统把页从磁盘调回内存 → 更新页表。
    
 (3) 内存保护问题

- 页表条目存在，但==访问权限不==匹配：
    
    - 例如虚拟页只允许读，但CPU尝试写
        
    - 或者是用户态访问内核态页
        
- 这类情况也会触发**异常**（严格说是保护异常，但机制类似缺页处理）。

2. 更新**TLB**：
    
    - 将新的“虚拟页 → 物理页框”映射写入TLB，以便下次快速访问。
        

---

### 步骤 4：生成物理地址

`物理地址 = 物理页框号 × 页大小 + 页内偏移`

然后CPU就能访问内存了。

---


# 多级

为了节省内存，现代操作系统通常使用**二级、三级甚至四级分页**。

假设是**二级分页**：

- **虚拟地址**拆成三部分：
    
    1. **一级页表索引（Page Directory Index）**
        
    2. **二级页表索引（Page Table Index）**
        
    3. **页内偏移（Offset）**
        

### 转换流程（二级页表）

1. CPU生成虚拟地址
    
2. 拆分成 **一级索引 + 二级索引 + 偏移**
    
3. **TLB查找**
    
    - 命中 → 直接得到物理页框 → 拼接偏移 → 物理地址
        
    - 未命中 → 访问一级页表 → 得到二级页表物理地址
        
    - 再访问二级页表 → 得到物理页框号 → 更新TLB
        
4. 拼接页内偏移 → 得到物理地址 → 访问内存
    

✅ 特点：

- 节省页表空间，不用一次性分配整张大页表
    
- 访问速度稍慢（TLB命中时仍然快）
    

---

### 3️⃣ 补充说明

- **TLB**缓存的就是“虚拟页号 → 物理页框号”的映射，无论是一级页表还是多级页表，命中TLB都能直接得到物理地址。
    
- **一级页表**只是最简单的分页表形式，如果虚拟地址空间很大，一级页表会很大，因此现代CPU通常用二级或多级页表。
    

---

💡 总结一句话：

> **一级页表只是分页机制中最简单的页表形式，虚拟地址通过页表逐级映射到物理页框，TLB则加速这个映射过程。**

---


# 转换（细致讲解）





[[虚拟内存-分页的原因]]
[[分页过程]]
[[缺页中断与malloc]]
## 分页的结构（以32位CPU为例）

在 32 位保护模式下：

- 虚拟地址长度：32 位（可寻址 4GB）
    
- 每页大小：4KB
    
- 那么可用页数 = 4GB ÷ 4KB = 1,048,576（≈ 一百万页）

==有特别多的页==

这些页都要“被映射”，  
所以 Intel 设计了两级结构，来分层查找：

`虚拟地址

┌────────────┬────────────┬────────────┐ │ 目录索引(10位) │ 页表索引(10位) │ 页内偏移(12位) │ └────────────┴────────────┴────────────┘`

👉 解释：

- **目录索引（10位）**：指出该虚拟地址属于哪个“页目录项”；
    
- **页表索引（10位）**：在那个页目录项指向的页表里，查第几个页；
    
- **页内偏移（12位）**：在页里偏移多少字节。
    

---

## 🧩 三、页目录与页表的关系PDE PTE

| 名称                  | 数量                       | 作用                     | 大小     |
| ------------------- | ------------------------ | ---------------------- | ------ |
| 页目录（Page Directory） | 1 个                      | 管理 ==1024 ==个页表（即目录项）  | 4KB    |
| 页表（Page Table）      | 最多 1024 个                | 管理 ==1024 个==页（也就是页表项） | 每个 4KB |
| 页（Page）             | 最多 1024×1024=1,048,576 个 | 每页 4KB 实际物理空间          | 4KB    |

==注意注意，页目录里面是表，页表里面是页==

| 名称                      | 作用                  | 包含内容           | 大小      |
| ----------------------- | ------------------- | -------------- | ------- |
| **页（Page）**             | 真实的数据页，映射到物理内存的一块区域 | 程序数据或代码        | **4KB** |
| **页表（Page Table）**      | 存放“每个页”的映射关系（虚拟→物理） | 1024 个页表项（PTE） | **4KB** |
| **页目录（Page Directory）** | 存放“页表的地址”           | 1024 个目录项（PDE） | **4KB** |

---

📊 这样就构成了一个完整的映射体系：

`虚拟地址  →  页目录项  →  页表项  →  物理页  →  实际数据`


## CPU 查找过程（翻译流程）

假设虚拟地址是 `0x12345678`  
我们拆成三部分：

|部分|位数|取值|用途|
|---|---|---|---|
|目录索引|10|0x48|找页目录项|
|页表索引|10|0xD1|找页表项|
|页内偏移|12|0x678|页内偏移|

CPU 的过程如下：

1️⃣ **从 CR3 寄存器取出页目录的物理地址**

> CR3 是专门保存“当前页目录表起始地址”的寄存器。

2️⃣ **用目录索引(10位)**  
→ 找到对应的页目录项（PDE）。  
PDE 里存放的是“页表的物理地址”。

3️⃣ **用页表索引(10位)**  
→ 进入那个页表（PT），找到对应页表项（PTE）。  
PTE 里存放的是“物理页框的物理地址”。

4️⃣ **加上页内偏移(12位)**  
→ 得到最终的物理地址。

CPU 就这样把虚拟地址变成了物理地址！



## 例子讲透整个过程

假设：

- 页目录起始地址 = 0x00100000（存放在CR3）
    
- 虚拟地址 = 0x12345678
    

1️⃣ 目录索引 = 0x48  
页目录项 = 0x00100000 + 0x48×4 = 0x00100120  
假设页目录项内容 = 0x00002007（页表在 0x00002000）

2️⃣ 页表索引 = 0xD1  
页表项 = 0x00002000 + 0xD1×4 = 0x00002444  
假设页表项内容 = 0x000AB007（物理页在 0x000AB000）

3️⃣ 页内偏移 = 0x678  
最终物理地址 = 0x000AB000 + 0x678 = 0x000AB678 ✅

CPU 就这样把虚拟地址“翻译”成功！

---

## 🔒 六、PDE,PTE 里的==控制位==

**Page Table Entry**  
中文意思：**页表项**

### 1. PDE（页目录项）的标志位

页目录项是一个 **32 位整数**（在 32 位系统里），里面包含两部分信息：

|位范围|内容|
|---|---|
|高 20 位|页表的物理地址（4 KB 对齐）|
|低 12 位|标志位 / 属性（P, RW, US 等）|

💡 关键：**页表地址必须 4 KB 对齐**

- 4 KB = 4096 字节 = 2¹² → 低 12 位全是 0
    
- 所以页表物理地址的低 12 位原本就是 0

### 2️⃣ OR 合并操作

`eax = 页表地址（0x101000） or eax, 0x7          ; 标志位 P=1,RW=1,US=1`

- 0x101000 的低 12 位是 `0000 0000 0000`
    
- OR 0x7（二进制 0111）只改变低 3 位
    
- 高 20 位的页表地址 **完全不变**
    

所以合并后的值：

`0x101000 | 0x7 = 0x101007`

- **高位地址不变** → CPU 仍然能正确找到页表
    
- **低位存放标志位** → CPU 能识别页表权限
    

---

### 3️⃣ 写入页目录项

`mov [PAGE_DIR_TABLE_POS], eax`

- 这一步把 **地址 + 属性** 一次性写入 PDE
    
- PDE[0] = 0x101007 → CPU 就能知道：
    
    1. 页表物理地址 = 0x101000
        
    2. P=1, RW=1, US=1


|位|名称|含义|
|---|---|---|
|bit0|P (Present)|页表是否存在|
|bit1|RW|页表是否可写|
|bit2|US|用户态是否可访问|
|bit3|PWT|页表写策略（可选）|
|bit4|PCD|页表缓存策略（可选）|
|bit5|A|访问位（CPU 会设置）|
|bit6|D|脏位（只有 PTE 有效）|
|bit7~11|可用位|软件使用|

> **核心：PDE 的标志位控制的是==页表本身的状态和权限**==

---

### 2. PTE（页表项）的标志位

PTE 指向一个 **实际物理页框**，结构和 PDE 类似，也有高 20 位地址和低 12 位标志位：


|位|名称|含义|
|---|---|---|
|bit0|P|页是否存在|
|bit1|RW|页是否可写|
|bit2|US|用户态是否可访问|
|bit3|PWT|页写策略|
|bit4|PCD|页缓存策略|
|bit5|A|访问位|
|bit6|D|脏位（表示该页被写过）|
|bit7|PAT|页属性表位（缓存策略）|
|bit8~11|可用位|软件使用|

> **核心：PTE 的标志位控制的是==页本身的状态和权限**==

---

### 3️⃣ 区别总结


||PDE|PTE|
|---|---|---|
|指向对象|页表|页框（物理页）|
|地址存放|页表物理地址|页框物理地址|
|权限控制|页表访问权限|页框访问权限|
|CPU 使用|CPU 会检查是否存在和权限|CPU 会检查权限、访问、脏位等|


> 所以标志位既可以叫 **标志位**，也可以叫 **控制位**，作用就是 **控制 CPU 如何访问对应的页或页表**。



页表项不只是存物理地址，还包含控制信息：

| 位   | 名称              | 说明          |
| --- | --------------- | ----------- |
| P   | Present         | 是否存在（1=页有效） |
| R/W | Read/Write      | 是否可写        |
| U/S | User/Supervisor | 用户态/内核态权限   |
| A   | Accessed        | 是否被访问过      |
| D   | Dirty           | 是否被修改过      |
| ... | ...             | 还有全局页、缓存控制等 |

这些控制位让内核能精细控制：

- 哪些页能被用户访问；
    
- 哪些页只读；
    
- 哪些页被频繁用。
    

---

## 💬 七、总结一句话

> **分页结构 = 页目录 + 页表。**  
> 页目录管页表，页表管页。
> 
> CPU 查地址时：  
> 虚拟地址 → 页目录 → 页表 → 物理页 → 内存。
> 
> 这样实现了：
> 
> - 每个进程独立虚拟空间
>     
> - 安全隔离
>     
> - 灵活映射
>     

---

💡类比记忆：  
页目录 = “目录本”，  
页表 = “索引卡”，  
页框 = “真正的书页”。  
CPU 查内存就像查书页——先查目录，再查索引卡，最后拿到真正那一页。

---


# 假设：没有页目录，只有一张“大页表”

你有一个程序，CPU 可以访问整个 4GB 虚拟空间。  
如果你要为 **整个4GB空间** 建一张“虚拟页 → 物理页”的映射表，就得有：

`4GB / 4KB = 1,048,576 项`

每项 4 字节 →

==`1,048,576 × 4 = 4MB`==

✅ 所以这张页表（一级页表）大小是 4MB。

---

## 🚨 三、浪费在哪里？

假设程序只用到了前 8MB 的虚拟地址空间，  
那它实际只访问了：

`8MB / 4KB = 2048 页`

也就是说，  
在那张 4MB 的大页表里：

- 前 2048 项是有效的；
    
- 后面 **1,048,576 - 2048 ≈ 1,046,528 项** 都没用。
    

---

💬 也就是说：

> 为了只记录前 8MB（2000多页），  
> 你不得不分配整张 4MB 的页表！

这就像：

> 打印了整本“全国电话簿📖”（一百万人），  
> 结果你只给自家三个人打电话。

😅 绝大部分页表项都是空的、没意义的。


## 于是就引入了“二级页表”

工程师想了个办法：

> 与其一次建一张 4MB 的大表，  
> 不如把这张表**拆成很多小表**。

---

### 拆法如下：

|层级|每个表有多少项|每项代表什么|能映射多少内存|
|---|---|---|---|
|页表|1024项|每项代表一个页（4KB）|4MB|
|页目录|1024项|每项指向一个页表|4GB|

这样就变成了一个“目录 + 小表”的结构👇

`页目录（1024项）  ├─ 第0项 → 页表0（管理前4MB）  ├─ 第1项 → 页表1（管理第4~8MB）  ├─ 第2项 → 页表2（管理第8~12MB）  ├─ ...`

---

## 🧠 五、现在看同样的 8MB 程序

程序只用了 8MB，所以：

- 它只需要第 0 个页表和第 1 个页表（各 4MB）
    
- 不需要再建剩下的 1022 个页表！
    

==每个页表 4KB==，  
所以页表总共：

`2 × 4KB = 8KB`

==再加上页目录 4KB，总共才 12KB==！

👉 从 4MB → 12KB，节省了 99.7% 的空间 ✨

假设程序只用了前 8MB：

|结构|总可映射空间|实际使用的表数量|实际占用内存|剩余映射能力|
|---|---|---|---|---|
|一级页表|4GB|1 张表|4MB|没变（但浪费）|
|二级页表|4GB|页目录 1 张 + 页表 2 张|4KB + 8KB = 12KB|还剩下 1016 张页表没建，可继续扩展|

🔹所以映射能力（4GB）没变，  
🔹只是实现方式更高效，浪费的空间大大减少。


- **一级页表**：一张表直接管 4GB，简单但浪费。
    
- **二级页表**：先有“目录表”指向小页表，每个页表只在用到时创建，更节省。

所以我们现在常说的“页目录 + 页表”就是二级分页结构。


## 结构对比总结

| 结构   | 层级数 | 页目录项（PDE） | 页表项（PTE）                              | 能映射的虚拟空间 | 总大小            |
| ---- | --- | --------- | ------------------------------------- | -------- | -------------- |
| 一级页表 | 1 层 | 无         | 1,048,576 项                           | 4GB      | 4MB            |
| 二级页表 | 2 层 | 1024 项    | 1024×1024=1,048,576 项（==每个页表有1024项==） | 4GB      | 理论上4MB（但可按需分配） |



## “为什么一级页表不能像二级页表那样按需创建？”

这个问题很多大学生都要想半天，我们现在慢慢讲清楚～

---

## 🧠 一、先复习：一级页表是“一个超大的表”

一级页表是这样的：

|虚拟页号|对应物理页框|
|---|---|
|0|0x001A3|
|1|0x0027C|
|2|0x00000|
|...|...|
|1,048,575|...|

它能覆盖整个 4GB 虚拟空间（1,048,576 页）。  
每个条目 4 字节 → 总共 4MB。

所以：

> “一级页表”其实就是一整张 4MB 的内存块。

---

## 🚨 二、CPU 的硬件设计让它**必须整张存在**

这就是关键点！  
分页机制是 CPU 硬件（MMU，内存管理单元）直接执行的。  
它**不会**像程序那样慢慢地去判断“这个页表存不存在”。

当 CPU 要访问一个虚拟地址时，它会立即：

1. 根据“页号”去页表里查；
    
2. 拿到页表项里的物理地址；
    
3. 访问对应的物理页。
    

🧩 所以问题来了：

> 如果页表的某一部分根本没分配内存，  
> CPU 就完全不知道那块“页表项”在哪里——  
> 它连“页表里第几行”的地址都找不到。

⚠️ 它不是在软件层面查数据，而是硬件“直接跳地址”的。

---

## 💡 三、类比理解

想象 CPU 就像个“自动查表机器人”🤖：

它拿到虚拟地址，就直接去翻那张“页表大纸”，  
按页号偏移直接取第 N 行。

- 如果那张大纸是完整的，它能直接找到；
    
- 如果你“没画完”，那块纸是空的，它就会读到**垃圾地址**或**非法内存**。
    

硬件不会像人那样想“哦，这一行还没写，我去创建一下”。

---

## 🧩 四、为什么二级页表就可以按需创建？

因为在二级页表里，多了一层“目录”！  
CPU 访问页表前，**会先查页目录项（PDE）**。

每个 PDE 里有一个控制位 **Present（P 位）**，  
如果这个页表不存在（P=0），CPU 知道：

> “哦，这个页表还没建，那我触发一个页异常（Page Fault）！”

然后系统（操作系统的内核）接管：

> “行，我来建一个新的页表，填上 PDE，再让你继续执行。”

✅ 这就是“按需创建”页表的机制。

而在一级页表中——没有这层“页目录”去标记“这一块页表还没建”。  
CPU 一上来就要访问页表的某一项，没有地方放那个“P=0”的标志。

---

## ⚙️ 五、再直观一点对比：

|对比项|一级页表|二级页表|
|---|---|---|
|页表数量|1 张超大表|多张小表（由页目录管理）|
|是否能按需分配|❌ 不行，必须整张分配|✅ 可以，只建用到的页表|
|硬件支持|没有额外标志|PDE 有 Present 位，能标记“页表存在”|
|空间效率|浪费内存|节省内存|
|出错机制|查不到就崩溃|可触发异常再创建|

---

## 📘 六、总结一句话

> 只有一级页表时，CPU 直接用虚拟页号计算页表项地址，  
> 它**必须知道整张页表的物理位置**，  
> 所以不能“按需创建部分”。
> 
> 而二级页表多了一层“页目录”，  
> CPU 先查页目录项，能知道“页表存在与否”，  
> 从而支持“页表按需创建”的机制。


# 一页4KB
1.是2的12次方，设计成2的N次方，就可以很方便地占地址线。
这个就是直接占用虚拟地址的后12位——页内偏移。

2.
>多了：会造成内存浪费，比如一页是1MB,那我要4KB的时候，也要用这个1MB,剩下的就都浪费了。

> 少了：页表项会特别多，页表项本身也占用内存，浪费

4KB是一个刚好居中的大小

3.
且，一个页表项占用4B,设计刚好页表中有1024项页表项，1024\*4=4KB,所以，页表和页目录本身也在物理内存各自占用一个页框。
（页框是物理内存的最小分配单位，4KB,对应关系）
如果不是经典的 32 位二级页表，“各自占 1 个页框” 就不成立：

1. 页大小不是 4KB：比如页大小为 8KB，此时页目录 / 页表的项数可能减少，但总大小若超过 8KB，就需要多个页框；若小于 8KB，也会按一个页框分配（页框是最小分配单位，不会拆分）。
2. 多级页表（三级 / 四级）：比如 64 位系统的四级页表，页目录（或更高层级的 “页目录指针表”）的大小可能超过 4KB，需要多个页框存储。


### 总结

在最常见的「32 位二级页表 + 4KB 页大小」场景下：

- 页目录：占用 1 个页框（固定）；
- 单个页表：占用 1 个页框（固定）；
- 整个进程的页表集合：占用 N 个页框（N≥1，取决于虚拟地址的使用范围）。
# 64位OS

有四级页表
页表项位数也变多了
对了，还有大页表的存在
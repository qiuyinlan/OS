
> ([[操作系统真象还原 (郑纲) (Z-Library).pdf#page=97&selection=337,1,339,9|p.97]])

（call 有去有回   jmp 不回来）

### `call` 与 `jmp` 的区别

| 指令     | 意思    | 返回性    | 常见用途                                                                                                                                  |
| ------ | ----- | ------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `jmp`  | 无条件跳转 | 一去不回   | BIOS → MBR → Loader 这种“接力棒”==转交==             ==jmp 属于一去不回头==地去执行新的代码，适用环境是“交接”，如我们的 BIOS 将接力棒交给 MBR，之后再也用不到 BIOS 其余的代码               |
| `call` | 调用子程序 | 去了还要回来 | 在==函数调用时==使用                                                          程序中有执行主线时，call指令用于执行完一段分支后再回来的情况，当然它能回来还是需要用 ==ret 或 retf 来配合== |



# call

> 在汇编言中，用 call 命令实现一个函数的调用
> call 指令不是一去不回头，它执行完目标函数后还是要回来的，所以它得提前把回来的路（返回地址）记好了，对于 CPU 来说，它是靠程序计数器 PC 来指路的，所以路就在 PC 中。凡是调用 call 指令，CPU 就要找地方把返回地址存起来以备将来函数执行时有路可以返回。

`call` 就是“调用子程序”的指令。  
它**有去有回**——程序会跳到一个新地方去执行，然后执行完再“返回”原处继续。
比如你写：

`call add_number`

CPU 就会：

1. **==把下一条指令的地址（返回地址）压入栈中==**
    
2. **跳转到标号 `add_number` 所在的位置执行**

> 16 位实模式相对近调用

> ([[操作系统真象还原 (郑纲) (Z-Library).pdf#page=97&selection=343,0,354,36|p.97]])
> 何谓近？call 指令所调用目标函数和当前代码段是同一个段，即在同一个 64KB 的空间内，所以只给出段内偏移地址就好了，不用给出段基址。强调一下，“近”就是指在同一段内，不用切换段，不用换段基址，只需给出段内偏移地址。



## call 的两种形式

| 类型          | 名称  | 特点                     |
| ----------- | --- | ---------------------- |
| `call near` | 近调用 | 只在当前段跳转（==CS 不变==）     |
| `call far`  | 远调用 | 跳转到另一个段（==CS、IP 都会变==） |

[[CSIP]]

## call near
- **near 调用的意思**
    
    - `near` = “近调用”，表示调用目标和当前 `call` 指令在 **同一个代码段（CS不变）**。
        
    - 所以 CPU 只需要知道“偏移量”就能跳转，而不是整个绝对地址。
        
- **指令格式**
    
    - `call near imm16` 的机器码是 `E8 ll hh`，共 **3 个字节**：
        
        - `E8`：操作码，说明是相对近调用。
            
        - `ll hh`：2 字节的有符号偏移量（相对地址）。



---

### 🔹第一部分：相对近调用回顾

- 例子：
    
    ```
    0000:0900 call .+6   ; e8 06 00
    ```
    
    - `CS = 0x0000`，`IP = 0x0900`。
        
    - `call .+6` 表示跳转到 **当前地址 + 6** 的地方。
        
    - 操作数 = `06`（相对偏移）。
        
    - CPU 计算目标地址：
        
        ```
        目标地址 = 当前IP + 操作数 + 指令长度
                  = 0x0900 + 0x06 + 0x03
                  = 0x0909
        ```
        
    - 所以，虽然机器码里存的是“相对偏移”，CPU **最终还是把它换算成绝对地址来用**。
        
- 执行过程：
    
    1. CPU 先把当前 IP（指令后的返回地址）压栈。
        
    2. 再把算出来的目标地址（0x0909）写进 IP。
        
    3. 流程就跳过去了。
        

---

### 🔹第二部分：间接绝对近调用

作者说：接下来讲另一种调用方式，
> ([[操作系统真象还原 (郑纲) (Z-Library).pdf#page=100&selection=177,0,179,11|p.100]])
> 16 位实模式===间接===绝对近调用


- **关键点：**
    
    - **间接（indirect）**：目标地址不是直接写死在指令里，而是“放在某个寄存器”或“某块内存”中。
        
        - 比如：
            
            ```asm
            call ax         ; 目标地址在 AX 里
            call [0x1234]   ; 目标地址在内存单元 0x1234 里
            ```
            
    - **绝对（absolute）**：这里用的就是目标函数的 ==**绝对地址**==（段内偏移），不像相对调用那样存的是“偏移量”。
        
    - **近调用（near）**：还是在同一个代码段里，CS 不变，只改 IP。
        
- **机器码形式：**
    
    - `call 内存寻址` → 操作码 `FF 16` + 地址
        
    - `call ax` → `FF D0`
        
    - `call cx` → `FF D1`
        
    - （不同寄存器对应不同机器码，书里没全列出来）
        
- **执行过程：**
    
    1. CPU 先把返回地址（当前 IP 的下一个指令地址）压栈。
        
    2. 再把寄存器/内存里存的绝对地址直接写进 IP。
        
    3. 跳转到目标地址。
        

---

### 📖 所以，这段文字的重点在对比：

1. **相对近调用**
    
    - 操作数是“==相对偏移量==”。
        
    - 机器码 `E8 + 偏移量`。
        
    - CPU 执行时要算：`IP + 偏移 + 指令长度` → 绝对地址。
        
2. **间接绝对近调用**
    
    - 操作数是“==寄存器/内存中保存的绝对地址==”。
        
    - 机器码以 `FF` 开头，根据寻址方式不同而变化。
        
    - CPU 执行时：直接取寄存器/内存里的数，丢进 IP。
        

---

👉 换句话说：

- **相对近调用**：机器码里放的是“跳几步（±offset）”。
    
- **间接绝对近调用**：机器码里指明“到哪去取地址”，最终目标就是“具体某个绝对地址”。
    
、

## far call
## 1️⃣ 先回顾 “near call”

- **near 调用**：只修改 IP，不修改 CS（段寄存器）。
    
- 只能在 **同一代码段** 内跳转。
    

---

## 2️⃣ 远调用（far call）的特点

- **far 调用**：同时修改 **CS 和 IP**，跨段执行函数。
    
- 为了能回来，CPU 会把 **旧的 CS 和 IP** 先压栈，再把新的 CS:IP 加载进去。
    
- 返回时，用 `retf`（远返回）把栈里的旧 CS 和 IP 弹出来。
    

---

## 3️⃣ 两种 far call 方式

### 🔹 （a）16 位实模式 **直接绝对远调用**

- **直接（direct）**：目标地址（段基址+偏移量）在指令里就写死了（立即数）。
    
- **绝对（absolute）**：地址就是一个确定的绝对 CS:IP，不需要计算相对量。
    
- 指令格式：
    
    `call far 段基址:偏移`
    
- 机器码格式：
    
    `9A + [2字节偏移量] + [2字节段基址]`
    
    注意顺序：机器码里是 **偏移在前，段基址在后**，和汇编写法相反。
    

例子：

`call far 0x0000:0x0907`

机器码：

`9A 07 09 00 00`

执行时：

1. 栈 ← 原来的 CS
    
2. 栈 ← 原来的 IP
    
3. CS ← 0x0000
    
4. IP ← 0x0907
    

跳到新段执行。

---

### 🔹 （b）16 位实模式 **间接绝对远调用**

- **间接（indirect）**：目标 CS:IP 不写死在指令里，而是放在 **内存** 中。
    
- **绝对（absolute）**：内存中保存的是确定的段基址+偏移值（共 4 字节）。
    
- **注意**：不支持寄存器寻址，只能用内存。
    

指令格式：

`call far [内存地址]`

例子：

`call far [0x1234]`

执行过程：

1. CPU 先根据 DS:0x1234 取 4 字节：
    
    - 前 2 字节 = 新的 IP
        
    - 后 2 字节 = 新的 CS
        
2. 栈 ← 旧 CS
    
3. 栈 ← 旧 IP
    
4. CS ← 新 CS
    
5. IP ← 新 IP
    

操作码是 `FF 1E`，表示 “call far [mem16]”。

---


- **near call（近调用）**
    
    - 调用的是 **同一段（CS不变）** 里的子程序。
        
    - 所以 CPU 在调用前 **只需要把返回地址（当前IP的下一条指令地址）压入栈**。
        
    - 返回时用 `ret` 指令，CPU 从栈中弹出IP即可。
        
- **far call（远调用）**
    
    - 调用的是 **不同段（CS要改变）** 的子程序。
        
    - CPU 在调用前要保存完整的“返回点”，所以 **先压入当前CS，再压入返回IP**。
        
    - 然后加载新的CS:IP，跳到目标子程序。
        
    - 返回时用 `retf` 指令，CPU 会从栈中依次弹出IP和CS，恢复到原来的段和偏移。
        

👉 所以：

- **near call 压栈：IP**
    
- **far call 压栈：CS + IP（先CS，后IP）**

## ret retf

（==近返回和远返回，就是用call的时候将下一条压入栈中，ret和retf就可以把栈顶东西弹出，一个弹出ip,一个是ip和cs==）

当 CPU 执行：

`call sub_func`

时，它做了两件事：

1. **把返回地址压栈**（即下一条指令的 `IP`，或 `CS:IP`）；
    
2. **跳转到目标函数（子程序）地址**。
    

所以函数执行完之后，要回来继续执行时，必须：

- 从栈里弹出返回地址；
    
- 跳回去。
    

而这件事就是 `RET` 或 `RETF` 干的。

## `RET`（Return Near）近返回

### 🌍 作用范围

只用于**同一段内的调用**（即段寄存器 `CS` 不变，只改 `IP`）。

### 🧠 执行过程

`ret`

执行时 CPU 会：

1. 从栈顶弹出一个 16 位的值（原来的 `IP`）；
    
2. 放回到 `IP` 寄存器；
    
3. 继续执行。
    

也就是说，它相当于：

`pop ip jmp ip`

### 📘 示例（书中 3.2.6）

`section ret_test vstart=0x900     call sub_func     mov ax, 0x1234     jmp $ sub_func:     mov bx, 0x5678     ret`

执行过程：

1. CPU 执行 `call sub_func` → 压栈返回地址（0x0903），跳到 `sub_func`；
    
2. 在 `sub_func` 中执行 `mov bx, 0x5678`；
    
3. 执行 `ret`，CPU 从栈顶弹出 0x0903 → 放回 `IP`；
    
4. 程序跳回 `mov ax, 0x1234` 继续执行。
    

---

## 🪜 三、`RETF`（Return Far）远返回

### 🌍 作用范围

用于**跨段调用**（段寄存器 `CS` 也要恢复）。

这通常配合 `CALL FAR` 或 `CALL FAR [mem]` 一起用。

### 🧠 执行过程

`retf`

执行时 CPU 会：

1. 从栈顶弹出 **`IP`**；
    
2. 再弹出 **`CS`**；
    
3. 把它们恢复；
    
4. 跳转回原段原地址继续执行。
    

相当于：

`pop ip pop cs jmp cs:ip`

### 📘 示例（书中 3.2.7）

`section call_test vstart=0x900     call far [addr]     jmp $ addr dw far_proc, 0 far_proc:     mov ax, 0x1234     retf`

执行顺序：

1. `call far [addr]` → CPU 压栈当前的 `CS:IP`；
    
2. 跳转到 `far_proc`；
    
3. 执行 `mov ax, 0x1234`；
    
4. 执行 `retf`，CPU 弹出返回的 `IP` 和 `CS`；
    
5. 跳回到原来的段。
    

---

## 📊 四、两者的区别总结表

|指令|作用|压栈内容|弹栈内容|适用范围|
|---|---|---|---|---|
|`RET`|返回到同一段|IP|IP|同一段（near call）|
|`RETF`|返回到不同段|CS:IP|CS + IP|跨段（far call）|

---


# jump

> ([[操作系统真象还原 (郑纲) (Z-Library).pdf#page=104&selection=112,0,157,11|p.104]])
> 无条件跳转，是指“生硬地”改变 CPU 航线，将程序流转移到新的位置。前面说过啦，CPU 的航线是段寄存器 CS 和 IP，所以 jmp 指令也是通过修改这两个寄存器来为 CPU 导航的。 jmp 转移指令只要更新 CS：IP 寄存器或只更新 IP 寄存器就好了，不需要保存它们的值，所以跳到新的地址后没办法再回来，它属于“一去不回头”地去执行新指令。和 call 一样，按远近（是否跨段）来划分，大致分为两类，近转移、远转移。不过在转移方式中，还有个更近的，叫短转移。


| 类别        | 操作数形式        | 修改内容  | 范围             |
| --------- | ------------ | ----- | -------------- |
| 短跳转       | 8 位立即数（一个字节） | IP    | -128 ~ +127 字节 |
| 近跳转（相对）   | 16 位立即数      | IP    | -32K ~ +32K 字节 |
| 近跳转（间接绝对） | 寄存器/内存       | IP    | 同段内任意位置        |
| 远跳转（直接绝对） | 段:偏移 立即数     | CS+IP | 任意段:偏移         |
| 远跳转（间接绝对） | 内存（4 字节）     | CS+IP | 任意段:偏移         |
直接给，或者通过寄存器
直接给，或者通过内存
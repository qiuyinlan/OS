# 获取内存

在 8086（最早的 CPU）里只有 20 根线==（A0～A19）==。  
它的寻址范围是：

`0x00000 ～ 0xFFFFF`

而且在 8086 上有个特别的“回绕现象”：

> 如果地址计算结果超过 1MB，就会回到开头。

比如段地址 0xFFFF，偏移 0x0010：

`物理地址 = 0xFFFF0 + 0x0010 = 0x100000（1MB）`

但因为 8086 ==只有 20 根线，A20 不存在==，  
所以第 21 位被丢掉，实际变成：

`0x00000`

也就是“绕回到开头”。

---

## 后来的 CPU（80286 及之后）

- 它们有 **A20 地址线**，可以访问更高的内存（>1MB）。
    
- 但为了**兼容旧程序（8086 模式）**，IBM 加了一个“开关”：
    
    - 关掉 A20 → 模拟旧的“回绕”行为
        
    - 打开 A20 → 可以访问真正的高地址


CPU 自己不会直接“拉低”或“切断”一根线。  
但是主板厂商为了兼容旧系统，  
在「键盘控制器」(8042) 或「芯片组」里，  
加了一个“电路开关”，  
用来决定这根 A20 地址线是否生效。

这就是「A20 Gate」。

CPU → 地址总线 → **主板芯片（控制A20 Gate）** → 内存

主板芯片会根据“开关状态”：

- 如果关：让 A20 信号被强制为 0
    
- 如果开：让 CPU 的 A20 信号原样通过
    

> 所以，“关掉A20”其实就是：  
> 把地址线 A20 的信号屏蔽掉，让 CPU 的第 20 位永远是 0。


---

## MBR 阶段为什么不用打开 A20？

- MBR 的地址：`0x7C00`
    
- 范围：在 1MB 之内，**A20 根本不会参与寻址！**
    
- 所以无论 A20 开不开，CPU 都能正常取到那里的指令。
    

🟢 只有当 loader 想访问 **1MB 以上的内存（例如 0x100000 处的内核）** 时，  
才需要把 A20 打开。



保护模式只是==让 CPU **“准备好”处理高地址**==；  
但如果 **A20 线没开**，  
那些高地址信号根本发不出去 —— 物理内存访问会错误或回绕。


想象 CPU 是一辆车：

|项|比喻|
|---|---|
|**保护模式**|你换成了“自动挡”，CPU会用新的寻址方式（GDT段机制）|
|**A20 开关**|高速公路收费口的闸门，开了才能真的上高速|
|→|换挡 ≠ 抬闸门，两个是不同系统|
# 代码
### 1️⃣ `mov eax, 0xE820`

👉 把功能号 `0xE820` 装入 `EAX`，告诉 BIOS：

> “我要调用中断 0x15 的功能号 E820 —— 请返回系统内存映射表。”

[[中断-功能号]]



### 2️⃣ `mov edx, 0x534D4150`

👉 这是关键的 **魔数标志（Signature）**。  
把十六进制常量 `0x534D4150` 装入 `EDX`。

翻译成 ASCII：

`0x53 = 'S' 0x4D = 'M' 0x41 = 'A' 0x50 = 'P'`

也就是字符串 `"SMAP"`。

📘 BIOS 通过检测 `EDX` 是否是 `"SMAP"` 来确认：

> “调用者知道 E820 这个接口的规则，我可以安全地返回结构化的内存信息。”

如果你不写这行，有的 BIOS 会认为你是老接口调用（比如 E801），从而拒绝执行。

---

### 3️⃣ `mov ecx, 20`

👉 指定你提供的**缓冲区大小**。  
BIOS 要把内存段信息写到你指定的 ES:DI 地址，这里告诉它：

> “我的缓冲区有 20 字节。”

这 20 字节对应一个标准的内存段描述结构：

|字段名|长度|说明|
|---|---|---|
|BaseAddrLow|4 字节|区域起始地址低 32 位|
|BaseAddrHigh|4 字节|区域起始地址高 32 位|
|LengthLow|4 字节|区域长度低 32 位|
|LengthHigh|4 字节|区域长度高 32 位|
|Type|4 字节|区域类型（1=可用内存，2=保留等）|


`ECX` 在这里表示——**你提供的缓冲区长度**。  
BIOS 会把每条“内存段信息”写到 ES:DI 所指向的地址。  
你必须告诉 BIOS：“我的这块内存有多大，可以写多少字节。”

在标准里，这个值固定是 20（十进制）。

|字段|长度|含义|
|---|---|---|
|BaseAddrLow|4 字节|起始地址低 32 位|
|BaseAddrHigh|4 字节|起始地址高 32 位|
|LengthLow|4 字节|长度低 32 位|
|LengthHigh|4 字节|长度高 32 位|
|Type|4 字节|区域类型（1=可用）|
---

### 4️⃣ `xor ebx, ebx`

`xor` 是“异或”指令。  

==任何数和自己异或都等于 0==



所以：

`xor ebx, ebx`

👉 等价于：

`mov ebx, 0`

只是它执行得更快（经典技巧 💡）。





👉 把 `EBX` 清零（即 `EBX = 0`）。

E820 的规定是：

- 第一次调用时，**EBX 必须是 0**。
    
- BIOS 返回后，会修改 `EBX`。
    
- 如果还有下一条内存记录，就返回新的 `EBX` 值。
    
- 当 `EBX = 0` 时，表示“已经到最后一条了”。
    

🧠 你可以把 `EBX` 理解为“页码编号”，每次调用翻下一页。

---

###  那为什么要把 EBX 清零呢？

因为 E820 规定：

> 第一次调用时，EBX 必须是 0。  
> BIOS 用 EBX 来记住“你读到第几条了”。

💡 可以类比成“页码编号”：

- 你第一次拿内存表时 EBX=0；
    
- BIOS 给你第1条记录；
    
- 并返回一个新的 EBX（比如 1）；
    
- 下次调用时你带上这个 EBX；
    
- BIOS 知道你上次读到第1条，就返回第2条；
    
- 一直到最后 EBX=0，表示结束。


### 5️⃣ `int 0x15`

👉 执行中断调用，正式进入 BIOS。

这时 BIOS 会：

1. 检查 `EAX=E820` 和 `EDX='SMAP'`；
    
2. 在内部找到内存映射表；
    
3. 把下一条内存段信息（20字节）写到 ES:DI 所指的缓冲区；
    
4. 返回时修改寄存器：
    

|寄存器|含义|
|---|---|
|CF|标志位：0=成功，1=失败|
|EAX|返回 `'SMAP'`（再次确认成功）|
|EBX|下一条记录的索引值（如果=0表示结束）|
|ECX|返回结构长度（一般也是20）|
|ES:DI|内存映射结构体地址|

---

### 6️⃣ `; BIOS 把结果写到 ES:DI 所指的内存结构里`

👉 ES:DI 就是你提供的缓冲区地址。  
BIOS 会在那个内存位置写入结构体（20字节）：

例如：

`BaseAddrLow = 0x00000000 LengthLow   = 0x0009FC00 Type        = 1  （可用）`

---

### 7️⃣ `; 如果 CF=0，说明成功`

👉 CF（进位标志）在这里用来表示调用是否成功：

- CF = 0 → 成功
    
- CF = 1 → 调用失败（比如 BIOS 不支持 E820）
    

---

### 8️⃣ `; EBX != 0 说明还有下一条记录`

👉 BIOS 会更新 EBX，如果它不是 0，表示还有更多内存区域没返回。  
你需要再次执行：

`int 0x15`

循环获取下一条，直到 EBX = 0 为止。

---

## ✅ 整体流程总结成一句话：

> 这段代码就是在实模式下，用 ==BIOS 的 `int 15h, ax=E820` 一次读取一条内存段信息==。  
> EAX 指明功能，EDX='SMAP' 验证接口，ECX=20 指定缓冲区大小，EBX=0 起始页，  
>==BIOS 把结果写到 ES:DI，并用 EBX 告诉你“还有没有下一段”==



💡 类比理解：  
你去问图书馆管理员（BIOS）要“内存地图”📖  
你说：“我有 20 字节的纸（ECX=20），一次请你写一页。”  
管理员看你出示了正确的“凭证”(`EDX='SMAP'`)，就帮你写下第一段（Base/Length/Type）。  
写完告诉你：“还有下一页，用这个号码(EBX)下次来取。”  
你再拿着 EBX 重复调用，直到他说：“没了，EBX=0”。


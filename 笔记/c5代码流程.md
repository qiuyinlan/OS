
## 🧱 第 5 章结构预览

> 第 5 章 保护模式进阶，向内核迈进
> 
> **5.1 获取物理内存容量**  
> **5.2 启用内存分页机制**

接下来，我们分两部分讲👇

---

# 🧩 第一部分：获取物理内存容量（5.1）

### 📘 背景

进入保护模式后，我们要开始**内存管理**。  
但首先，操作系统得知道自己有多少内存。  
所以第一步是：**检测物理内存容量**。

---

### 📖 书中方法

书上模仿了 Linux 的做法，调用 BIOS 中断 `int 0x15` 的几个子功能：

|功能号|描述|支持范围|
|---|---|---|
|`EAX=0xE820`|遍历主机上全部内存|最通用|
|`AX=0xE801`|检测 15MB 以下和 16MB～4GB|较旧|
|`AH=0x88`|最多检测出 64MB|最早|

📍这些 BIOS 中断都是在 **实模式** 下调用的，  
所以必须在进入保护模式前执行。

---

### 💡 原理

BIOS 会在内存中返回一个结构体（叫 **内存映射表**），  
里面每一项都有：

```c
BaseAddrLow   // 起始物理地址低 32 位
BaseAddrHigh  // 高 32 位
LengthLow     // 区域长度低 32 位
LengthHigh    // 高 32 位
Type          // 类型 (1=可用内存, 2=保留)
```

通过多次调用 `int 0x15`，直到 BIOS 不再返回数据。

---

### 🧠 CPU 状态

此时 CPU 仍在实模式中，利用 BIOS 的服务。  
检测完成后，loader 会保存结果，准备进入分页阶段。

---

# 🧩 第二部分：启用分页机制（5.2）

进入保护模式后，我们马上要“**虚拟化地址空间**”。

---

## 5.2.1 为什么要分页

分页的目标是：

- 把 **虚拟地址** 和 **物理地址** 分离；
    
- 让每个程序看到独立的地址空间；
    
- 便于内存保护和管理。
    

📘 一页（Page）= 4KB  
页目录（Page Directory）+ 页表（Page Table）= 两级映射结构

---

## 5.2.2 一级页表

页目录表有 1024 项，每项（PDE）指向一个页表；  
每个页表也有 1024 项，每项（PTE）指向一个 4KB 页。

**1024 × 1024 × 4KB = 4GB** 的地址空间。

---

## 🧩 代码说明（出自书中第 5 章）

```asm
PAGE_DIR_TABLE_POS equ 0x100000  ; 页目录表放在物理地址 1MB
```

💬 这代表：

> 页目录表的物理地址是 0x100000，刚好是 1MB 处（越过低端内存区）。

因为我们之前打开了 A20，现在已经能访问 1MB 以上内存了。

---

### 创建页目录表

```asm
mov ecx, 4096      ; 页目录表大小 4KB
mov ebx, PAGE_DIR_TABLE_POS
xor eax, eax
.clear_page_dir:
    mov [ebx], eax
    add ebx, 1
    loop .clear_page_dir
```

💡 把页目录表清零，避免脏数据干扰。

---

### 创建页表（建立恒等映射）

恒等映射 = 虚拟地址 == 物理地址

```asm
mov eax, 0x00000083   ; 页表项的物理地址 + 属性位
mov ebx, PAGE_DIR_TABLE_POS
mov [ebx], eax        ; 第 0 项 PDE 指向第一个页表
```

属性位（P、R/W、U/S）：

- P = 1 → 页存在
    
- RW = 1 → 可写
    
- US = 0 → 内核级
    

---

## 5.2.5 启用分页机制

分页开关在 `CR0` 的 **第 31 位 PG 位**。

```asm
mov eax, cr0
or eax, 0x80000000    ; 设置第 31 位 PG=1
mov cr0, eax
```

这样 CPU 就进入“分页模式”啦 🎉

此时地址转换流程是：

> 虚拟地址 → 页目录表（CR3 指向） → 页表 → 物理地址

---

## 5.2.6 用虚拟地址访问页表

验证是否映射成功，比如读写高地址的内存。

---

## 5.2.7 快表 TLB

TLB（Translation Lookaside Buffer）是 CPU 内部的**页表缓存**。  
如果每次访问内存都查页表，会很慢，所以 CPU 会自动缓存最近的映射结果。

---

# 🎯 总结

|阶段|目标|关键指令|CPU 状态|
|---|---|---|---|
|获取内存容量|读取 BIOS 返回的内存布局|`int 15h`|实模式|
|建立页目录表|初始化分页结构|`mov`, `loop`|保护模式|
|启用分页|设置 CR3, CR0.PG=1|`mov cr3`, `mov cr0`|分页模式|
|验证映射|访问高地址测试分页|`mov`, `jmp`|虚拟地址空间生效|

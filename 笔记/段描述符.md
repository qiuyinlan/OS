[[段]]

# 段描述符

无论是 16 位、32 位，还是 64 位保护模式，**每个段描述符（Segment Descriptor）都是==64位==，==8字节==（64 bit）**


> 描述符是存在==**内存里**的结构==，不在寄存器里。  
  即使 CPU 是 16 位的，也完全能读取和解析 8 字节的数据。  
  因为 CPU 不是一次性“装进去”，而是==分批读取==，再缓存起来用。


每个段都由一个 **段描述符（Segment Descriptor）** 来描述【记录段的属性】。  
段描述符保存在 **GDT（全局描述符表）** 或 **LDT（局部描述符表）** 中。

在保护模式下，每个段（代码段、数据段、栈段）都有一个**段描述符**，存放在 GDT/LDT 中。

段描述符告诉 CPU：

（本身属性 段类型，权限 + 大小  基址和界限）

1. **段基址（Base Address）**：段在内存的起始地址
    
2. **段界限（Limit）**：段的大小（最大偏移）
    
3. **访问权限和特权级**  
    
4. ==**段类型**（代码段/数据段/系统段等）==  在高4字节部分



> 可以把段描述符理解成“段的身份证”，记录了段的起点、长度、用途和权限。

| 字段      | 位数   | 作用              |
| ------- | ---- | --------------- |
| Base    | 32   | 段基址             |
| Limit   | 20   | 段界限             |
| Type    | 4    | 段类型             |
| **P**   | 1    | 是否存在（1=存在，0=无效） |
| DPL     | 2    | 段的特权级           |
| G、D/B 等 | 其他属性 |                 |

因为p记录是否存在，所以，
GDT_BASE:
    dd 0x00000000
    dd 0x00000000                 ; 空描述符
对应的就是空描述符


# 特权级
段描述符里有一个字段叫 **DPL（Descriptor Privilege Level，描述符特权级）**
- 值范围：0 ~ 3
    
    - **0**：最高特权（内核态）
        
    - **3**：最低特权（用户态）
        
- **代码段的 DPL**：==规定了哪些特权级的程序可以执行这个代码段的指令==。


## 当前特权级（CPL）

- **CPL（Current Privilege Level）**：当前正在执行代码的特权级，由 CS 的低两位决定。
    
- CPU 每条指令执行时都会用 CPL 来检查权限。

##  代码段访问规则

保护模式下，CPU 执行指令时，会检查 **CPL 和代码段 DPL**：

|情况|是否允许执行| 说明                                       |
| --------- | ------ | ---------------------------------------- |
|CPL ≤ DPL|✅ 允许执行| 当前特权级足够高，代码可以执行                          |
|CPL > DPL|❌ 不允许| 当前特权级太低，不能执行高特权代码，CPU 会产生 **GP（通用保护异常）** |
### 特殊情况

1. **向下调用**（从低特权调用高特权）
    
    - 保护模式允许从低特权级调用高特权代码，但必须经过 **调用门（Call Gate）**
        
    - 调用门会做安全检查，可能切换栈到高特权级。
        
2. **向上跳转**（高特权执行低特权代码）
    
    - 一般允许，因为高特权级的程序可以访问低特权段（安全无问题）

[[段保护机制]]


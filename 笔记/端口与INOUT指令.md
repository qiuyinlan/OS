# 端口号与寄存器

主要原因就是立即数有大小限制。

### 1️⃣ `out` / `in` 指令限制

x86 的 I/O 指令只有两种形式：

1. **端口号在 DX 寄存器里**
    

`out dx, al   ; DX 是端口号 in al, dx`

- 这适合 **任意 16 位端口号**，比如 `0x1F2`、`0x3F6`，都可以通过 DX 传给指令。
    

2. **端口号是 8 位立即数**
    

`out 0x42, al  ; 只能是 0~255 的端口`

- 只能访问 **低 256 个端口**（0x00~0xFF）。
    
- 超过 0xFF 的端口号就不行了，需要用 DX。
    

---

### 2️⃣ 为什么硬盘端口用 DX

- 硬盘端口从 **0x1F0 ~ 0x1F7**，有的寄存器需要 16 位端口访问
    
- 所以只能写：
    

`mov dx, 0x1f2 out dx, al`

- 如果你直接写 `out 0x1f2, al`，CPU 会报错或者汇编不通过（因为立即数必须 <= 0xFF）。
    

---

### 3️⃣ 小结

- **DX 方式**：可以访问所有 0~65535 的端口（任意硬件）
    
- **立即数方式**：只能访问 0~255 的小端口
    
- 所以 MBR 代码里必须用 `mov dx, port` → `out dx, al`
    

> 类比：你要找仓库窗口，DX 就像写了一张地址卡，告诉 CPU 从哪扇门取东西；小端口直接写数字，只能用门 0~255 的那几扇。



# 端口与INOUT指令

[[IO接口]] [[寄存器]] [[硬盘]] [[显卡]]

## 什么是端口

**端口 (Port)** 是 [[IO接口]] 中的寄存器，用于 CPU 与外设之间的数据交互。

- **为什么叫"端口"？**
  - 为了区别于 CPU 内部的[[寄存器]]
  - IO 接口中的寄存器 = 端口

⚠️ **注意**：这里的端口不是网络应用程序的端口（如 80 端口）！

## 端口的作用

### IO 接口为什么要用寄存器？

- CPU 本身只能直接操作 **CPU 内部寄存器**或**内存**
- 外设（键盘、显示器、硬盘）不是内存，也不是 CPU 寄存器
- 需要一个"中转站" → **端口**

### 端口的类型

| 端口类型 | 作用 | 示例 |
|---------|------|------|
| **数据端口** | 存放要传输的数据 | 硬盘数据端口 0x1F0 |
| **状态端口** | 反映设备当前状态 | 硬盘状态端口 0x1F7 |
| **控制端口** | 接收控制命令 | 硬盘命令端口 0x1F7 |

## 端口编号

每个端口有一个**端口号**（地址）。

### 端口号范围

- **8 位端口号**：0x00 ~ 0xFF（256个端口）
- **16 位端口号**：0x0000 ~ 0xFFFF（65536个端口）

### 常见端口号

| 端口号   | 设备/功能     | 类型    |
| ----- | --------- | ----- |
| 0x1F0 | 硬盘数据端口    | 数据    |
| 0x1F1 | 硬盘错误/特性   | 状态/控制 |
| 0x1F2 | 扇区计数      | 控制    |
| 0x1F3 | LBA low   | 控制    |
| 0x1F4 | LBA mid   | 控制    |
| 0x1F5 | LBA high  | 控制    |
| 0x1F6 | Device    | 控制    |
| 0x1F7 | 状态/命令     | 状态/控制 |
| 0x3D4 | VGA 索引寄存器 | 控制    |
| 0x3D5 | VGA 数据寄存器 | 数据    |

参见：[[硬盘]] [[显卡]]

## IN 指令 - 从端口读取

**IN** 指令用于从端口读取数据到 CPU 寄存器。

### 基本格式

```nasm
in al, dx     ; 从端口 DX 读 8 位数据到 AL
in ax, dx     ; 从端口 DX 读 16 位数据到 AX
in al, 立即数  ; 从端口号（立即数）读数据到 AL
```

### 固定用法

| 部分 | 限制 |
|-----|------|
| 源操作数（端口号）| **必须是 DX** 或 8 位立即数 |
| 目的操作数 | **必须是 AL 或 AX** |

- 端口号用 **DX** 存储（16位，可表示 0-65535）
- 目的寄存器：
  - **AL**：读取 8 位数据
  - **AX**：读取 16 位数据

### 示例

```nasm
; 读取硬盘状态
mov dx, 0x1F7    ; 端口号
in al, dx        ; 从 0x1F7 读取状态到 AL

; 读取8位立即数端口
in al, 0x60      ; 从端口 0x60 读取键盘扫描码
```

参见：[[硬盘]]

## OUT 指令 - 写入端口

**OUT** 指令用于将 CPU 寄存器的数据写入端口。

### 基本格式

```nasm
out dx, al       ; 将 AL 写入端口 DX
out dx, ax       ; 将 AX 写入端口 DX
out 立即数, al    ; 将 AL 写入端口号（立即数）
out 立即数, ax    ; 将 AX 写入端口号（立即数）
```

### 固定用法

| 部分 | 限制 |
|-----|------|
| 目的操作数（端口号）| **DX** 或 8 位立即数 |
| 源操作数 | **AL 或 AX** |

**注意**：IN 和 OUT 相反
- **IN**：端口 → 寄存器（源是端口）
- **OUT**：寄存器 → 端口（目的是端口）

### 示例

```nasm
; 向硬盘发送读命令
mov dx, 0x1F7    ; 命令端口
mov al, 0x20     ; 读扇区命令
out dx, al       ; 发送命令

; 写入8位立即数端口
mov al, 0x0A
out 0x20, al     ; 向端口 0x20 写入 0x0A
```

## 为什么不能用 MOV 指令？

### MOV 是内存指令

```nasm
mov ax, [0x1F0]    ; ❌ 错误！试图把内存地址 0x1F0 的数据读到 AX
```

- **MOV** 访问的是**内存地址空间**
- **端口**不在内存地址空间，而在**IO地址空间**

### IN/OUT 是端口指令

```nasm
in ax, 0x1F0       ; ✅ 正确！从端口 0x1F0 读取数据
```

- **IN/OUT** 触发不同的总线信号
- CPU 知道要访问 IO 端口，而不是内存

### 内存空间 vs IO空间

| 空间类型 | 访问指令 | 地址范围 |
|---------|---------|---------|
| **内存空间** | MOV, PUSH, POP... | 0 ~ 4GB (32位) |
| **IO空间** | IN, OUT | 0 ~ 65535 (16位) |

## 硬盘端口操作示例

### 读取硬盘扇区

```nasm
; 1. 设置扇区数
mov dx, 0x1F2
mov al, 1         ; 读1个扇区
out dx, al

; 2. 设置 LBA 地址（低8位）
mov dx, 0x1F3
mov al, sector_lba_low
out dx, al

; 3. 设置 LBA 地址（中8位）
mov dx, 0x1F4
mov al, sector_lba_mid
out dx, al

; 4. 设置 LBA 地址（高8位）
mov dx, 0x1F5
mov al, sector_lba_high
out dx, al

; 5. 设置 device 寄存器
mov dx, 0x1F6
mov al, 0xE0      ; LBA模式 + 主盘
out dx, al

; 6. 发送读命令
mov dx, 0x1F7
mov al, 0x20      ; 读扇区命令
out dx, al

; 7. 等待硬盘准备好
.wait:
mov dx, 0x1F7
in al, dx         ; 读取状态
test al, 0x08     ; 测试 DRQ 位
jz .wait          ; 未就绪则继续等待

; 8. 读取数据
mov dx, 0x1F0
mov cx, 256       ; 一个扇区512字节 = 256个字（word）
.read_loop:
in ax, dx         ; 从数据端口读取 16 位
stosw             ; 存储到 ES:DI，DI += 2
loop .read_loop
```

参见：[[硬盘]] [[CHSLBA]]

## 显卡端口操作示例

### 设置光标位置

```nasm
; 设置光标位置 (x, y)
; 光标偏移 = y * 80 + x

; 1. 设置高8位
mov dx, 0x3D4     ; VGA 索引寄存器
mov al, 0x0E      ; 光标位置高8位寄存器索引
out dx, al

mov dx, 0x3D5     ; VGA 数据寄存器
mov al, bh        ; 光标位置高8位
out dx, al

; 2. 设置低8位
mov dx, 0x3D4
mov al, 0x0F      ; 光标位置低8位寄存器索引
out dx, al

mov dx, 0x3D5
mov al, bl        ; 光标位置低8位
out dx, al
```

参见：[[显卡]]

## 端口访问的特点

### 1. 端口号必须用 DX

大多数情况下，端口号要先放到 DX：

```nasm
mov dx, 0x1F0
in ax, dx
```

**例外**：8 位立即数端口可以直接写：

```nasm
in al, 0x60     ; 可以，端口号 < 256
in al, 0x1F0    ; ❌ 错误！端口号 > 255
```

### 2. 数据宽度由寄存器决定

- **AL/AH**：8 位端口
- **AX**：16 位端口

```nasm
in al, dx     ; 读 8 位
in ax, dx     ; 读 16 位
```

### 3. 顺序很重要

某些设备要求**特定的端口访问顺序**。

例如硬盘：
1. 先设置参数（扇区数、LBA）
2. 再发送命令
3. 最后读取数据

❌ **顺序错误可能导致设备工作异常！**

## 端口访问权限（保护模式）

在[[保护模式]]下，访问端口需要权限：

### IOPL (I/O Privilege Level)

- FLAGS 寄存器的第 12-13 位
- 决定哪个特权级可以访问 IO 端口

### I/O 位图（TSS）

- 任务状态段（TSS）中的 IO 权限位图
- 每个端口对应一个位
- 0 = 允许，1 = 禁止

参见：[[TSS]] [[特权级]]

## 总结

### 端口的本质

- **端口 = IO 接口中的寄存器**
- 用于 CPU 和外设之间的数据交互

### IN/OUT 指令

| 指令 | 功能 | 格式 |
|-----|------|------|
| **IN** | 端口 → 寄存器 | `in al/ax, dx` |
| **OUT** | 寄存器 → 端口 | `out dx, al/ax` |

### 关键点

1. **端口号用 DX**（或 8 位立即数）
2. **数据用 AL/AX**
3. **不能用 MOV**（MOV 是内存指令）
4. **访问顺序很重要**

### 常见应用

- [[硬盘]]：读写扇区（端口 0x1F0-0x1F7）
- [[显卡]]：设置光标、显存（端口 0x3D4, 0x3D5）
- 键盘：读取扫描码（端口 0x60）
- 中断控制器：发送 EOI（端口 0x20, 0xA0）

参见：[[IO接口]] [[硬盘]] [[显卡]]

# 中断

[[IO接口]] [[BIOS]] [[CPU执行指令]] [[FLAGS寄存器]]
[[中断-功能号]]

## 什么是中断

**中断 (Interrupt)** 是一种机制，允许硬件或软件**打断 CPU 当前的工作**，让 CPU 去处理更紧急的事情。

- **英文**：Interrupt（打断）
- **本质**：CPU 暂停当前工作，转去执行中断处理程序
- **完成后**：返回原来的位置继续执行

## 为什么需要中断？

### 问题：轮询效率低

如果没有中断，CPU 需要**轮询**检查设备状态：

```nasm
; 无中断：CPU 必须反复查询
.wait_loop:
    mov dx, 0x1F7
    in al, dx           ; 读取硬盘状态
    test al, 0x08       ; 检查数据就绪位
    jz .wait_loop       ; 没准备好就继续等
    ; 准备好了才能读数据
```

**缺点**：
- CPU 一直在循环等待，浪费时间
- 无法同时处理其他任务

### 解决：中断驱动

有了中断，设备准备好后会**主动通知 CPU**：

```
设备准备好 → 发送中断信号 → CPU 暂停当前工作 → 处理数据 → 继续原来工作
```

**优点**：
- CPU 不用轮询，可以做其他事
- 设备准备好了才通知，效率高

参见：[[IO接口]]

## 中断的类型

### 按来源分类

| 类型 | 来源 | 示例 |
|-----|------|------|
| **硬件中断 (外部中断)** | 硬件设备 | 键盘、硬盘、定时器 |
| **软件中断 (内部中断)** | 软件指令 | `int 0x10`, `int 0x21` |
| **异常 (Exception)** | CPU 内部错误 | 除零错误、缺页异常 |

### 按是否可屏蔽分类

| 类型 | 是否可屏蔽 | 说明 |
|-----|----------|------|
| **可屏蔽中断** | 是 | CPU 可以选择暂时忽略 |
| **不可屏蔽中断 (NMI)** | 否 | CPU 必须立即处理 |

## 中断的工作流程

### 中断处理步骤

```
1. 设备发出中断信号
   ↓
2. CPU 检测到中断请求
   ↓
3. 保存当前状态（压栈）
   ↓
4. 查找中断向量表，获取中断处理程序地址
   ↓
5. 跳转到中断处理程序
   ↓
6. 执行中断处理程序
   ↓
7. 恢复现场（出栈）
   ↓
8. 返回原来的位置继续执行 (iret)
```

### 保存和恢复现场

**保存现场**（CPU 自动完成）：
```nasm
; CPU 自动压栈
push FLAGS    ; 保存标志寄存器
push CS       ; 保存代码段
push IP       ; 保存指令指针
```

**恢复现场**（中断返回指令）：
```nasm
iret          ; 中断返回 (Interrupt Return)
              ; 相当于：
              ; pop IP
              ; pop CS
              ; pop FLAGS
```

参见：[[FLAGS寄存器]] [[栈与指针]]

## 中断向量表 (IVT)

### 什么是中断向量表

**中断向量表 (Interrupt Vector Table, IVT)** 是一个数组，存储所有中断处理程序的入口地址。

- **位置**：内存地址 **0x00000** 开始
- **大小**：1KB (256 个中断 × 4 字节)
- **每项内容**：中断处理程序的段基址和偏移地址

参见：[[实模式]] [[BIOS]]

### 中断向量表结构

```
每个中断向量占 4 字节：
  - 偏移地址 (2 字节)
  - 段基址 (2 字节)

中断号 n 的向量地址 = n × 4

示例：
- 中断 0：地址 0x00000 (除零异常)
- 中断 1：地址 0x00004 (单步调试)
- ...
- 中断 0x10：地址 0x00040 (BIOS 视频服务)
- 中断 0x13：地址 0x0004C (BIOS 磁盘服务)
```

### 常用 BIOS 中断

| 中断号 | 功能 |
|-------|------|
| **INT 0x10** | 视频服务（显示字符、设置光标）|
| **INT 0x13** | 磁盘服务（读写扇区）|
| **INT 0x16** | 键盘服务（读取按键）|
| **INT 0x15** | 系统服务（获取内存信息）|
| **INT 0x1A** | 时钟服务（获取时间）|

参见：[[BIOS]] [[显卡]] [[硬盘]]

## 软件中断指令

### INT 指令

```nasm
int 中断号    ; 触发软件中断
```

**示例**：

```nasm
; 使用 BIOS 中断显示字符
mov ah, 0x0E      ; 功能号：显示字符
mov al, 'A'       ; 要显示的字符
int 0x10          ; 调用 BIOS 中断 0x10
```

### INT 指令的执行过程

```nasm
; int 0x10 的执行过程

1. push FLAGS     ; 保存标志寄存器
2. CLI            ; 清除中断允许标志（禁止嵌套中断）
3. push CS        ; 保存代码段
4. push IP        ; 保存指令指针
5. 查找 IVT[0x10]  ; 中断向量表第 0x10 项
6. CS:IP = IVT[0x10]  ; 跳转到中断处理程序
```

## 数据传输方式与中断

### 1. 无条件传送

- CPU 随时可以取数据
- **缺点**：效率低，CPU 会空等

### 2. 查询传送 (PIO)

```nasm
; 查询传送：轮询检查状态
.wait:
    in al, 0x1F7    ; 读取状态
    test al, 0x08   ; 检查就绪位
    jz .wait        ; 未就绪则继续等待
    in al, 0x1F0    ; 就绪了才读数据
```

**缺点**：CPU 需要轮询，浪费时间

### 3. 中断驱动

```
设备准备好 → 发送中断 → CPU 处理数据
```

**优点**：
- CPU 不用轮询
- 效率高

### 4. DMA (Direct Memory Access)

```
设备 → 直接写入内存
      ↓
    完成后发送中断通知 CPU
```

**优点**：
- CPU 不参与数据传输
- 效率最高

参见：[[IO接口]]

## 硬件中断

### 中断控制器

**8259A 可编程中断控制器 (PIC)** 负责管理硬件中断。

- **主 PIC**：管理 IRQ 0-7
- **从 PIC**：管理 IRQ 8-15
- **级联**：从 PIC 连接到主 PIC 的 IRQ2

### IRQ 分配

| IRQ | 设备 |
|-----|------|
| IRQ 0 | 定时器 |
| IRQ 1 | 键盘 |
| IRQ 2 | 级联到从 PIC |
| IRQ 3 | COM2 (串口) |
| IRQ 4 | COM1 (串口) |
| IRQ 5 | LPT2 (并口) |
| IRQ 6 | 软盘驱动器 |
| IRQ 7 | LPT1 (并口) |
| IRQ 8 | 实时时钟 |
| IRQ 14 | 主硬盘 |
| IRQ 15 | 从硬盘 |

### 中断响应

硬件中断的响应过程：

```
1. 硬件设备发出中断请求
   ↓
2. 8259A 向 CPU 发送中断信号
   ↓
3. CPU 完成当前指令
   ↓
4. 检查 FLAGS 的 IF 位（中断允许标志）
   ↓
5. 如果 IF=1，响应中断
   ↓
6. 保存现场，跳转到中断处理程序
```

### 中断屏蔽

```nasm
; 禁止中断
CLI           ; Clear Interrupt Flag (IF = 0)

; 允许中断
STI           ; Set Interrupt Flag (IF = 1)
```

参见：[[FLAGS寄存器]]

## 中断处理程序

### 中断处理程序的结构

```nasm
; 中断处理程序示例
my_interrupt_handler:
    ; 1. 保存寄存器（如果需要）
    push ax
    push bx

    ; 2. 执行中断处理逻辑
    ; ...

    ; 3. 发送 EOI (End Of Interrupt) 给 8259A
    mov al, 0x20
    out 0x20, al    ; 通知主 PIC

    ; 4. 恢复寄存器
    pop bx
    pop ax

    ; 5. 中断返回
    iret
```

### EOI (End Of Interrupt)

**EOI** 是告诉中断控制器"中断处理完成"的信号。

```nasm
; 发送 EOI 给主 PIC
mov al, 0x20
out 0x20, al

; 如果是从 PIC 的中断，需要发送两次
out 0x20, al    ; 主 PIC
out 0xA0, al    ; 从 PIC
```

参见：[[端口与INOUT指令]]

## 异常

### 常见异常

| 异常号 | 名称 | 原因 |
|-------|------|------|
| 0 | 除零异常 | 除数为 0 |
| 1 | 调试异常 | 单步执行 |
| 3 | 断点异常 | 遇到断点指令 |
| 6 | 无效操作码 | 非法指令 |
| 13 | 一般保护异常 | 访问越界、权限错误 |
| 14 | 缺页异常 | 访问未映射的页 |

### 异常处理

```
异常发生 → CPU 自动查找 IVT → 跳转到异常处理程序
```

如果没有设置异常处理程序，系统会崩溃（死机）。

## 实模式 vs 保护模式的中断

### 实模式

- 使用**中断向量表 (IVT)**
- 位置：内存 0x00000
- 每项 4 字节：段:偏移

### 保护模式

- 使用**中断描述符表 (IDT)**
- 位置：由 IDTR 寄存器指定
- 每项 8 字节：段选择子 + 偏移 + 属性

参见：[[实模式]] [[保护模式]]

## 总结

### 中断的核心作用

1. **提高效率**
   - 避免轮询
   - CPU 可以同时处理多任务

2. **异步通信**
   - 设备准备好后主动通知 CPU
   - CPU 和设备解耦

3. **异常处理**
   - 处理错误情况
   - 防止系统崩溃

### 中断的分类

```
中断
├── 硬件中断（外部）
│   ├── 可屏蔽中断 (IRQ)
│   └── 不可屏蔽中断 (NMI)
├── 软件中断（内部）
│   └── INT 指令
└── 异常
    ├── 除零异常
    ├── 缺页异常
    └── 一般保护异常
```

### 中断处理流程

```
1. 发出中断信号
2. 保存现场 (push FLAGS, CS, IP)
3. 查找中断向量表/中断描述符表
4. 跳转到中断处理程序
5. 执行中断处理
6. 发送 EOI
7. 恢复现场 (iret)
```

### 关键指令

| 指令 | 功能 |
|-----|------|
| **int n** | 触发软件中断 |
| **iret** | 中断返回 |
| **cli** | 禁止中断 |
| **sti** | 允许中断 |

参见：[[IO接口]] [[BIOS]] [[FLAGS寄存器]] [[CPU执行指令]]

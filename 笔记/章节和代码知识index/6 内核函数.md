[[mm6]]

# 内核中函数调用约定与 C/汇编混合编程的底层机制是什么？
[[内核函数调用规定]]
# 内核如何实现自己的打印函数，并且能够打印字符、字符串和整数？
[[硬件]]
[[内核打印]]
[[标准库libc]]
[[文件系统加载]]
[[文件系统]]
[[操控硬件]]

(描述的一些东西，一般在内存加载。具体的，要去磁盘里找，文件系统是磁盘，跟内存没关系，别搞混了)


# 用户进程与内核的交互
[[内存分区]]

> 大伙儿知道，用户进程有自己的 4GB 虚拟地址空间，这空间中除了存放用户进程自己的指令和数据外，还要包括用户进程自己的堆和栈，用户进程可以在自己的堆中申请、释放内存，因此必须有一套方法跟踪内存的分配情况。和内核一样，用户进程也是用位图来管理地址分配的，每个进程有自己单独的位图，存储在进程 pcb 中的 userprog_vaddr 中。”

> “进程是单独执行的个体，每个进程都有自己的返回值，那返回值存放在哪里呢？估计您也想到了，为了方便管理，与进程相关的数据都统一放在 pcb 中，当进程生命结束时，它的遗言，也就是返回值，会被内核放在 pcb 中。另外，进程在调用 exit 时就表示进程生命周期结束了，其占用的资源可以被回收了，因此进程在调用 exit 后，内核会把该进程占用的大部分资源都回收，比如内存、页表等，但肯定不能将进程的 pcb 所占的内存回收，原因是里面存储着子进程的遗言，必须要交付给父进程，父进程收到子进程的遗言后才能回收子进程的 pcb，否则子进程会‘死不瞑目’。”

---

### 补充讲解：用户进程与内核的交互

1. **虚拟地址空间管理**
    
    - 每个用户进程都有自己的虚拟地址空间（通常 4GB，低 3GB 用户空间，高 1GB 内核共享）。
        
    - 内核负责为每个进程建立页表，并在内核态时操作页表来分配、保护内存。
        
    - 用户态程序自己无法访问其他进程或内核空间，只能访问自己虚拟空间中的页。
        
2. **PCB（Process Control Block）**
    
    - 每个进程都有 PCB，内核用它存储进程状态、寄存器值、堆栈位置、内存分配信息等。
        
    - 当用户进程执行系统调用或退出时，内核会在 PCB 中记录重要信息（如退出码）。
        
3. **系统调用桥梁**
    
    - 用户进程通过系统调用（如 `fork()`, `exit()`, `wait()`）进入内核态。
        
    - 内核从 PCB 和进程页表中读取信息，执行实际操作（创建子进程、回收资源、访问硬件等）。
        
4. **数据传递与上下文切换**
    
    - 内核通过在内核栈中保存用户栈信息来访问和修改用户进程的数据。
        
    - fork、exec、wait 等系统调用涉及将用户态上下文保存到内核栈或 PCB，再切换 CPU 执行内核代码，操作完成后恢复用户态。
        
5. **资源隔离与共享**
    
    - 每个用户进程有独立的页表和内存管理位图，保证隔离。
        
    - 高 1GB 内核空间在所有进程中共享，实现内核功能统一访问。
        
    - 内核负责同步内核页表，确保所有进程陷入内核时能正确访问内核资源。
        

---

简而言之，用户进程和内核的交互就是：

`用户进程（特权级 3） → 系统调用 int 0x80 → 内核态（特权级 0） → PCB/页表管理/资源操作 → 返回用户态`

整个流程确保用户程序不能直接操作硬件或其他进程资源，同时内核能集中管理和调度系统资源。
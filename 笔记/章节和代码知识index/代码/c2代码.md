  
[[c2流程图]]
  [[中断-功能号]]
  第 4 行：mov ax, cs

  为什么用 cs？
  - BIOS 在跳转到 MBR 前，设置了 cs=0, ip=0x7c00
  - 我们需要把其他段寄存器也设为 0
  - 但 8086 不允许 mov ds, 0（不能直接给段寄存器赋立即数）
  - 必须通过通用寄存器中转

  第 5-8 行：mov ds/es/ss/fs, ax

  把 ds、es、ss、fs 都设为 0，原因：
  - 统一段基址：所有段都从 0 开始
  - 简化地址计算：物理地址 = 0 × 16 + 偏移 = 偏移
  - 这样我们用 vstart 计算的地址就是正确的物理地址

  第 9 行：mov sp, 0x7c00

  sp 是栈顶指针，为什么设为 0x7c00？

  关键：栈是向下增长的！

  内存布局：
  0x0000  ← 栈向这里增长
    ...
  0x7bff  ← push 后 sp 会减小到这里
  0x7c00  ← sp 初始值（栈顶）
  0x7c00  ← MBR 代码开始
  0x7dff  ← MBR 代码结束

  为什么不能设成 0x7dff？
  - 如果 sp=0x7dff，第一次 push 会写入 0x7dfd-0x7dfe
  - 这会覆盖 MBR 代码！（MBR 在 0x7c00-0x7dff）

  为什么设成 0x7c00 安全？
  - push 会先 sp = sp - 2，再写入内存
  - 第一次 push 写入 0x7bfe-0x7bff
  - 在 MBR 下方，不会覆盖代码 ✅

  ---
  💡 为什么不初始化会出错？

  假设 BIOS 把段寄存器留成随机值（比如 ds=0x1000）：

  mov ax, message    ; ax = 0x7c38（vstart 算的）
  mov bp, ax
  ; 后面 BIOS 中断用 es:bp 访问字符串

  实际访问的地址：
  es × 16 + bp = 0x1000 × 16 + 0x7c38 = 0x10000 + 0x7c38 = 0x17c38

  结果：访问的不是 0x7c38，而是 0x17c38（完全错误的地方）！

  ---



# 打印mbr

在你贴的这段 **x86 BIOS 中断 0x10 功能代码**里：

```
`mov ah, 0x06        ; 功能号（滚屏/清屏） 
mov al, 0           ; 滚动行数`
```

- `AL` 是 **AX 寄存器的低 8 位**（AX 是 16 位寄存器，分成 AH 和 AL 两部分）
    
- 在这个功能号里，`AL` 用来指定 **滚动的行数**：
    
    - `0` 表示 **清屏（滚动整块区域）**
        
    - 其他数字 n 表示 **向上滚动 n 行**
        

所以在你的例子里，`AL = 0` 的意思就是 **整块区域清空屏幕**，而不只是滚动部分内容。

---

## 光标打印
[[vga]]
第 32 行：mov bh, 0

  mov bh, 0

  什么是"页号"？

  VGA 文本模式支持多个视频页（类似多个虚拟屏幕）：
  - 显卡内存有 32KB（文本模式）
  - 一页 = 80×25×2字节 = 4000 字节
  - 可以有多页，但同时只显示一页
  - 页号 0 是默认页

  为什么要分页？
  - 可以在后台准备下一页内容
  - 切换页实现快速刷新（类似双缓冲）
  - 我们简单起见，只用第 0 页


## 什么是 `int` 指令？

- `int` 全称是 **Interrupt**（中断）
    
- 它是 x86 CPU 的一条 **指令**，用来触发 **软中断**（软件中断）
    
- 语法：
    
    `int <中断号>`
    
    比如：
    
    `int 0x10`
    
    → 调用 **中断号 0x10** 对应的中断处理程序（这里是 BIOS 视频服务）
    

---

## 2️⃣ `int` 是怎么“执行”的

当 CPU 遇到 `int n` 时，会做这些步骤：

1. **保存现场**
    
    - CPU 会把当前 **CS、IP、FLAGS** 压栈
        
    - 这样中断结束后能回来继续执行原来的程序
        
2. **查找中断向量表**
    
    - x86 内存最前面的 1024 字节保存了 **中断向量表（IVT）**
        
    - 每个中断号占 4 字节，保存 **段地址:偏移地址**
        
    - CPU 会用 `n` 查找对应的地址
        
3. **跳转执行中断处理程序**
    
    - CPU 跳到 IVT 指向的内存地址
        
    - 执行该中断处理程序里的指令
        
    - 你在 BIOS 中看到的各种功能就是这些程序
        
4. **返回原程序**
    
    - 中断处理完后执行 `iret`（Interrupt Return）
        
    - CPU 弹栈恢复 CS、IP、FLAGS
        
    - 原来的程序继续执行

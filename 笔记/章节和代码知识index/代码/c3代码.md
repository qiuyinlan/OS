[[显卡#显存地址计算]]

[[0汇编语法#显存]]

[[端口与INOUT指令#端口编号]]
# rd_disk_m_16

在 x86 汇编里，“函数”和“标签”之间没有像高级语言里那样明确的区分，它们本质上都是 **代码地址的名字**。判断 `rd_disk_m_16` 是函数，主要依据几个方面：

---

### 1️⃣ 有输入输出约定

看这个标签：

`rd_disk_m_16:`

紧接着有一段代码，它用 **寄存器传递参数**：

- `EAX` = LBA 扇区号
    
- `EBX` = 内存写入地址
    
- `ECX` = 扇区数
    

函数的典型特征就是 **有明确的输入输出**，这里 `BX`/`CX`/`AX` 等寄存器在调用前后有意义。

---

### 2️⃣ 有调用指令

在 MBR 里你看到：

`call rd_disk_m_16`

- `call` 是 x86 调用指令，会把下一条指令地址压栈，然后跳到 `rd_disk_m_16` 执行。
    
- 这就是典型函数调用行为，而不是单纯跳转到标签。
    

如果只是 `jmp rd_disk_m_16`，那更像一个无返回的跳转。


我们可以分步骤来看它做了什么：

---

### 1️⃣ 函数输入

它通过寄存器接收参数：

|寄存器|含义|
|---|---|
|`EAX`|要读取的起始 LBA 扇区号（逻辑扇区地址）|
|`EBX`|内存写入的起始地址|
|`ECX`|要读取的扇区数量|

---

### 2️⃣ 备份寄存器

`mov esi, eax  ; 保存起始扇区号 mov di, cx    ; 保存扇区数量`

- 避免后续操作修改原始参数。
    

---

### 3️⃣ 设置硬盘寄存器，准备读扇区

`mov dx, 0x1f2 mov al, cl out dx, al`

- `0x1F2` 是硬盘寄存器，用于告诉硬盘要读多少扇区。
    

然后它把 LBA 扇区号拆开写到 `0x1f3 ~ 0x1f6` 端口，这是 ATA 硬盘标准的 **LBA 28 位寻址方式**。

---

### 4️⃣ 发送读命令

`mov dx, 0x1f7 mov al, 0x20  ; 读命令 out dx, al`

- 告诉硬盘：“请开始把指定扇区的数据读出来”。
    

---

### 5️⃣ 等待硬盘准备好

`.not_ready: in al, dx and al, 0x88 cmp al, 0x08 jnz .not_ready`

- 检查硬盘状态寄存器：
    
    - 第 4 位 = 1 表示数据可用
        
    - 第 7 位 = 1 表示硬盘忙
        
- 只有硬盘准备好才继续。
    

---

### 6️⃣ 读取数据到内存

`mov ax, di mov dx, 256 mul dx       ; 计算总读取次数 mov cx, ax  mov dx, 0x1f0 .go_on_read: in ax, dx mov [bx], ax add bx, 2 loop .go_on_read`

- 每个扇区 512 字节，每次读取 2 字节（16 位），循环读取所有扇区，写入 `BX` 指向的内存地址。
    

---

### 7️⃣ 返回调用点

`ret`

- `call` 调用的地方继续执行下一条指令。
    

---

### ✅ 总结

这个函数就是 **一个低级硬盘读取函数**，完成：

1. 告诉硬盘要读哪个扇区（LBA 地址）
    
2. 告诉硬盘读多少扇区
    
3. 等硬盘准备好
    
4. 将扇区数据读到内存
    
5. 返回调用点
    

在 MBR 中，它通常用来读取 **操作系统引导程序** 或 **loader** 的第一个扇区到内存，以便继续启动。

---


# 宏

### 总结关系

|符号|值|含义|
|---|---|---|
|`LOADER_START_SECTOR`|0x2|loader 在硬盘上的起始扇区号|
|`LOADER_BASE_ADDR`|0x900|loader 被加载到内存的起始地址|


001,这里loader就是002

0x900是随便选的，在1m剩余空间里随便挑。


# 调用rddisk过程，难懂代码点

[[CHSLBA]]  
[[端口与INOUT指令#端口编号]]
mov eax, LOADER_START_SECTOR   ; 起始扇区号
mov bx, LOADER_BASE_ADDR       ; 写入内存地址
mov cx, 1                       ; ==读几个扇区==
call rd_disk_m_16

```

mov dx,0x1f2
mov al,cl
out dx,al
```

先让端口号写入寄存器，因为端口号太大了
[[端口与INOUT指令]]

- ==`0x1F2` 是 **扇区数量寄存器端口**  是一个工具，用来读取，读取多少————看CL==
    
- `cl` = 扇区数（最多 255 个）
    
- `out dx, al` = 往硬盘窗口写入要读多少扇区
    

> 类比：告诉仓库管理员：“我想取 1 篇资料。”




### 3️⃣ 写 LBA 地址到端口 0x1F3~0x1F6

硬盘读取指定扇区需要 LBA 地址（逻辑块地址）。==LBA 32 位，需要分 4 个端口写入。==

`mov dx,0x1f3 out dx,al`

- 低 8 位写入 0x1F3
    

`mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al`

- 低 8 位移掉，剩下中间 8 位写到 0x1F4
    

`shr eax,cl mov dx,0x1f5 out dx,al`

- 再移 8 位，写到 0x1F5
    

`shr eax,cl and al,0x0f or al,0xe0 mov dx,0x1f6 out dx,al`

- 高 4 位 + 高 4 位模式 `0xE0` 写到 0x1F6
    
- 0xE0 = 固定标志，表示 LBA 模式 + 选择硬盘 0
    

> 类比：告诉仓库管理员：“我想取的是第 1000 篇资料，分门别类写在表单里。”

---

### 4️⃣ 发送读命令

`mov dx,0x1f7 mov al,0x20 out dx,al`

- 0x1F7 是 **命令端口**
    
- 0x20 = ATA 命令 “读扇区”
    
- 硬盘收到后会准备数据
    

> 类比：仓库管理员拿到表单后开始去仓库取资料。

---

### 5️⃣ 等待硬盘准备好

`.not_ready: nop in al,dx and al,0x88 cmp al,0x08 jnz .not_ready`

- `in al, dx` = 从命令端口读状态
    
- `al & 0x88`：
    
    - bit7 = Busy（忙）
        
    - bit3 = DRQ（数据准备好）
        
- `cmp al,0x08` = 等待 DRQ=1，Busy=0
    
- `jnz .not_ready` = 如果还没准备好，继续等
    

> 类比：仓库还在整理资料，你在门口等着通知“可以取了”。

---

### 6️⃣ 从硬盘读取数据到内存

`mov ax, di mov dx, 256 mul dx mov cx, ax mov dx, 0x1f0`

- 每扇区 512 字节 (`256 * 2` 个字)
    
- `cx` = 要读的 **16 位字数量**
    
- `0x1F0` = 数据端口
    

`.go_on_read: in ax,dx mov [bx],ax add bx,2 loop .go_on_read`

- 每次从 0x1F0 读 **2 个字节（AX）**
    
- 写入内存地址 `[bx]`
    
- bx += 2 移到下一个内存位置
    
- 循环直到读完所有扇区
    

> 类比：仓库管理员递给你每张资料，你按顺序放进文件夹里，直到拿齐。

---

### 🔹 总结

1. **告诉硬盘要读多少扇区**
    
2. **告诉硬盘从哪读（LBA）**
    
3. **发送读取命令**
    
4. **等待硬盘准备好**
    
5. **一个字节/两个字节一个字节地读数据到内存**
    

💡 核心思路：**下命令 → 等待 → 取数据 → 放内存**，端口就是下命令和取数据的通道。




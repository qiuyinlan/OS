[[c4代码流程]]
==学习构造gdt,开启a20,开启保护模式。


章节结构如下👇：

| 节号  | 内容                               | 对应文件                   |
| --- | -------------------------------- | ---------------------- |
| 4.1 | 创建 `boot.inc` 公共头文件              | boot.inc（inc——include) |
| 4.2 | 构造 GDT（全局描述符表）                   | loader.asm             |
| 4.3 | 实模式下打印字符串                        | loader.asm             |
| 4.4 | 打开 A20、加载 GDT、设置 CR0.PE=1、跳转保护模式 | loader.asm             |
| 4.5 | 在保护模式下操作显存打印 `P` 字符              | loader.asm             |




==以下是头文件内容==
# GDT
```

; GDT 描述符属性（高 4 字节部分）
DESC_CODE_HIGH4  equ 0x00CF9A00         ; 代码段，DPL=0
DESC_DATA_HIGH4  equ 0x00CF9200         ; 数据段，DPL=0
DESC_VIDEO_HIGH4 equ 0x000F9200         ; 显存段，DPL=0
```
DESC 就表示 “描述符”

CODE 表示这是一个 代码段

HIGH4 表示这是描述符的 高4字节

|数字|二进制|意思|
|---|---|---|
|9A|`1001 1010`|可执行、可读、内核、存在（代码段）|
|92|`1001 0010`|不可执行、可写、内核、存在（数据段）|

就像：

- `9A` 这张门票写着「可以读、可以执行」→ 程序代码用
    
- `92` 这张门票写着「可以读、可以写」→ 数据区用

这三个东西，其实是**三张不同的门票**：

`代码段  → DESC_CODE_HIGH4 数据段  → DESC_DATA_HIGH4 显存段  → DESC_VIDEO_HIGH4`

它们都在 **GDT表** 里一行一行放着，不会互相覆盖，  
就像表格的三行，每行各写自己的数据。
（他们是不同的段，当然不冲突了，对应的是不同段的段描述符）
```


; GDT 选择子标志
TI_GDT equ 0       ; GDT
RPL0   equ 0
RPL3   equ 3
```

- `TI = 0` → 使用 **全局描述符表 GDT**
    
- `TI = 1` → 使用 **局部描述符表 LDT**
    

所以这里写 `TI_GDT equ 0`，意思是：

> 我们所有段描述符都在 GDT 中，没有使用 LDT。


## 构造 GDT（全局描述符表）

这是 loader.asm 的开头部分👇

`%include "boot.inc"               ; 引入刚才的头文件 section loader vstart=LOADER_BASE_ADDR LOADER_STACK_TOP equ LOADER_BASE_ADDR jmp loader_start                  ; 跳过 GDT 数据区`

### 🧠 CPU 为什么要 `jmp loader_start`？

📘 书里解释：

> loader 一开始这段区域是数据（GDT 表），如果不跳过，CPU 会当作指令去执行，造成崩溃。

所以必须先 `jmp` 跳到后面真正的执行入口。



数据/栈段
> “先进入保护模式，成功显示一个 ‘P’。”

此时还没有内核、没有任务、没有堆栈切换机制。  
所以作者为了**简化逻辑**，  
让数据段和栈段**共用同一个段描述符**。


>跟c的逻辑类似，都是先定义，后面再用。不是每一行代码都是cpu的代码


```
GDT_BASE:
    dd 0x00000000
    dd 0x00000000                 ; 空描述符

CODE_DESC:
    dd 0x0000FFFF
    dd DESC_CODE_HIGH4            ; 代码段

DATA_STACK_DESC:
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4            ; 数据/栈段

VIDEO_DESC:
    dd 0x80000007
    dd DESC_VIDEO_HIGH4           ; 显存段

```

dd是4字节，两个dd刚好就是8字节，构成段描述符

# 段选择子
```
SELECTOR_CODE  equ (0x0001<<3) + TI_GDT + RPL0
SELECTOR_DATA  equ (0x0002<<3) + TI_GDT + RPL0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0

```

左移，index是前13位
你只要用几个段，就只需要几个段选择子
- GDT 定义了 3 个段：代码段、数据段、显存段
    
- 所以 **3 个段选择子就够了**
# 打印字符串
```
mov sp,LOADER_BASE_ADDR
mov bp,loadermsg
mov cx,17
mov ax,0x1301
mov bx,0x001f
mov dx,0x1800
int 0x10

```

[[寄存器]]

### `mov sp, LOADER_BASE_ADDR`

- **作用**：设置 **栈指针 SP**
    
- `LOADER_BASE_ADDR` 是你的引导程序在内存中的起始位置
    
- 栈需要有空间存放函数调用、返回地址、临时数据等
    
- 设置 SP 保证之后操作不会破坏内存其他地方
    

> 💡 简单理解：SP 指向“栈顶”，这是 CPU 访问栈用的寄存器



`LOADER_BASE_ADDR` 是你 loader 被加载到的内存位置，比如书里假设是某个地址 `0x900`。这是你自己定义的，只要是内存可用区域就可以了，mbr用完就可以覆盖了。

### 2️⃣ `mov bp, loadermsg`

- **作用**：把字符串地址存入 **BP 寄存器**
    
- `loadermsg` 是你要显示的字符串，比如 `"2 loader in real."`
    
- 后面调用 `int 10h` 时，会用 BP 指向的地址去读取字符串
    

> 💡 注意：BP 在实模式下常用作指针寄存器

### 3️⃣ `mov cx, 17`

- **作用**：CX 寄存器存放 **字符串长度**
    
- 这里字符串长度是 17 个字符
    
- BIOS 会根据 CX 的值输出对应长度的字符串
    

---

### 4️⃣ `mov ax, 0x1301`

- **作用**：设置 `AX` 用于调用 BIOS 功能
    
- `int 0x10` 是 BIOS 显示中断
    
- AH = 0x13 表示功能号（在 BIOS 文档里，功能号 13h 是 **打印字符串**）
    
- AL = 0x01 表示打印方式，比如带光标移动、颜色等
    

> 可以拆开理解：
> 
> `AH = 0x13 AL = 0x01 AX = AH<<8 + AL = 0x1301`

---

### 5️⃣ `mov bx, 0x001f`

- **作用**：设置显示属性
    
- 对于彩色文本模式，BX 低字节通常表示显示页，高字节表示颜色
    
- 这里 0x1F：
    
    - 前 4 位（1）是背景色
        
    - 后 4 位（F=15）是前景色（白色）
        

---

### 6️⃣ `mov dx, 0x1800`

- **作用**：设置光标位置
    
- DX 的高字节 = 行（row）
    
- DX 的低字节 = 列（column）
    
- 这里 0x18 = 24 行，0x00 = 第 0 列
    
- 所以光标定位到屏幕第 25 行第 1 列（从 0 开始计数）
    

---

### 7️⃣ `int 0x10`

- **作用**：调用 BIOS 中断，执行 **显示字符串操作**
    
- 根据 AX、BX、CX、DX、BP 寄存器的值，BIOS 会把 `loadermsg` 指向的 17 个字符显示到屏幕上，光标定位在 DX 指定位置，颜色 BX 指定。

==你写的 `"2 loader in real."` 打印，是为了 **调试和确认 Loader 成功执行**==
# 打开 A20、加载 GDT、开启保护模式

```
in  al, 0x92
or  al, 0000_0010B
out 0x92, al

lgdt [gdt_ptr]

mov eax, cr0
or  eax, 0x00000001
mov cr0, eax

jmp  SELECTOR_CODE:p_mode_start

```



## 1️⃣ `in al, 0x92`

- **作用**：从 **8042 控制器端口 0x92** 读一个字节到 AL 寄存器。
    
- ==**0x92 端口**：在 PC 早期是 **系统控制端口**，用来控制 CPU 初始化和 A20 地址线。==


- **为什么读？**：我们想先读取当前控制寄存器的值，准备修改某一位。
    

---

## 2️⃣ `or al, 0000_0010B`

- **作用**：把 AL 的==第 1 位（A20 门控制位）置 1==。
    
- `0000_0010B` = 二进制 `00000010` → 对应十六进制 `0x02`
    
- **为什么？**：开启 **A20 地址线**，保证 CPU 能访问 1MB 以上内存，否则保护模式访问高地址会出问题。

---



### 想法：只改一位，不动其他位

假设 AL 寄存器里面有一些状态，每一位都是一个开关：

`AL = 0101 1010`

- 比如第 1 位（从右数）控制 A20 地址线
    
- 其他位可能控制别的硬件状态，我们**不想改变它们**
    

如果你直接写：

`mov al, 0000_0010B`

- 那就把 AL 里的原来值完全覆盖了
    
- 其他控制开关的状态都丢掉了 → 很危险！
    

>  使用 OR

用 `or al, 0x02` 就等于：

- **只把第 1 位置 1**
    
- **其他位保持原样**
    

原理就是按位“或”：

|AL位|0x02位|OR结果|
|---|---|---|
|0|1|1|
|1|1|1|
|其他|0|保持原样|

所以安全又稳妥。


- ==硬件规定：通过向端口 0x92（或键盘控制器端口）写一个字节：
    
    - 第 0 位：系统复位开关
        
    - ==**第 1 位：A20 门开关**==
    - 其他位：保留或控制别的功能
        
- 所以你写 `or al, 0x02`：
    
    - 意思就是 **把第 1 位置 1** → 通知硬件打开 A20 地址线
        
    - 硬件就把 CPU 的 A20 线路连上 → CPU 可以访问 1MB 以上内存

- 我们只是想 **开启 A20 地址线**，并不想让 CPU 重启。
    
- 所以写入时要 **保持第 0 位为 0**。



## 3️⃣ `out 0x92, al`

- **作用**：把修改后的 AL 写回 0x92 端口
    
- **效果**：A20 门打开 → CPU 可以访问 1MB 以上内存
    

---

## 4️⃣ `lgdt [gdt_ptr]`

（从那个内存地方读到cpu里面的对应寄存器gdtr去）

- **作用**：==加载 **全局描述符表 GDT** 的地址和长度到 CPU 的 GDTR 寄存器==
    
- **为什么？**：保护模式下，所有段寄存器（CS、DS、SS…）都依赖 GDT
    
- `[gdt_ptr]` 指向的是一个 ==**结构体**==，格式一般是：
    
    `gdt_ptr:     dw gdt_limit   ; GDT 大小-1     dd gdt_base    ; GDT 起始地址`
    


- `lgdt` = **Load Global Descriptor Table Register**  
意思是：

> 把 GDT 的“地址”和“长度”告诉 CPU，让 CPU 知道 GDT 在哪。
==`[gdt_ptr]` 其实就是一块内存，里面放着 **GDT 的长度和基地址**==。

代码中一般写：

```
gdt_ptr:
    dw gdt_limit      ; GDT 的大小 - 1 （因为从0开始计）
    dd gdt_base       ; GDT 的起始物理地址

```
比如：

`gdt_limit dw 23       ; 24字节长（3个描述符，每个8字节） gdt_base  dd 0x90000  ; GDT 表存在内存 0x90000 处`

CPU 做了两件事：

1. 从 `[gdt_ptr]` 地址读出 6 个字节：
    
    - 前 2 字节 → limit
        
    - 后 4 字节 → base
        
2. 把这两个值加载进自己的 **GDTR 寄存器**。
    

从此：

> CPU 知道“GDT 在哪、长度是多少”，  
> 保护模式下所有段寄存器的解析就都基于它。



## 5️⃣ `mov eax, cr0`

- **作用**：把 CPU 的 **控制寄存器 CR0** 值读到 EAX
    
- **CR0** 控制 CPU 模式和特性
    

---

## 6️⃣ `or eax, 0x00000001`

- **作用**：把 CR0 的最低位（PE 位，Protection Enable）置 1
    
- **意义**：开启 **保护模式**
    
- 在这一条之后，CPU 仍然在当前指令执行完后才真正切换模式
    
### `CR0.PE=1` 是什么意思？

`PE` 位是 **Protection Enable**（保护模式使能）。  
当：

- `CR0.PE = 0` → CPU 处于 **实模式（Real Mode）**
    
- `CR0.PE = 1` → CPU 进入 **保护模式（Protected Mode）**
---

## 7️⃣ `mov cr0, eax`

- **作用**：把修改后的值写回 CR0 → CPU 进入 **保护模式**
    
- 保护模式一旦开启：
    
    - 段寄存器使用选择子 + GDT
        
    - 实模式的寻址方式失效
        
    - 可以使用分页、特权级等功能
        

---

## 8️⃣ `jmp SELECTOR_CODE:p_mode_start`

- **作用**：执行 **远跳（Far Jump）**
    
- 格式：`jmp 段选择子:偏移`
    
- **为什么要跳？**：
    
    1.==强制刷新 CS 寄存器==，使 CPU 真正切换到保护模式下的段机制
        
    2. 跳到保护模式下的代码入口 `p_mode_start`
        
- `SELECTOR_CODE` 是 GDT 中 **代码段的选择子**

以 **CS（代码段寄存器）** 为例：

- 在**实模式**：  
    CS 的值直接用于算物理地址
    
    `物理地址 = CS × 16 + IP`
    
- 在**保护模式**：  
    CS 不再是直接地址，而是一个 **段选择子（selector）**，  
    它指向 **GDT 表** 里的某个“段描述符”。
    

也就是说：

> CS 寄存器在保护模式下，代表“你在哪个段执行”。

---

问题关键来了：

当你刚设置 `CR0.PE=1` 时，

- CPU 还没刷新 CS；
    
- 也还没根据 GDT 去加载新的段描述符；
    
- 此时的 CS 寄存器里，仍然是“实模式的段值”。
    

结果就是：

> CPU 虽然理论上进入了保护模式，  
> 但实际还是按“实模式的段寄存器内容”去取指令。
> 
> 这会让 CPU 混乱（比如取错地址、GDT 无效、直接崩溃）。

---

解决办法：**远跳转（Far Jump）**

`jmp selector:offset`  
就是告诉 CPU：

> “立刻用我给你的段选择子（selector）刷新 CS，并从这个段重新取指令。”




---

## 🔑 总结整个流程

1. **打开 A20 门** → CPU 能访问 1MB 以上内存
    
2. **加载 GDT** → CPU 知道各段在哪里
    
3. **开启保护模式** → CR0.PE = 1
    
4. **远跳刷新 CS** → 真正切换到保护模式，执行保护模式代码
    

> 这是 **实模式 → 保护模式** 的标准套路。

---



# Q&A

## GDT和A20

| 阶段                                 | 动作            | 是否需要 A20                   |
| ---------------------------------- | ------------- | -------------------------- |
| 实模式（刚加载 MBR）                       | 还在 1MB 以下工作   | ❌ 不需要                      |
| 构造 GDT（loader 阶段）                  | 定义 GDT 数据结构   | ❌ 只是在 1MB 以下的内存中定义         |
| ==加载 GDT（`lgdt [gdt_ptr]`==）       | 告诉 CPU GDT 在哪 | ❌ GDT 通常放在 0x90000～0x9FFFF |
| 开启 A20（`or al, 0x02`）              | 打开 21 根线      | ✅ 允许访问 1MB 以上内存            |
| 切入保护模式（`mov cr0, eax` + `jmp far`） | CPU 进入保护模式    | ✅ 保护模式下可能访问更高内存            |


##  为什么必须 **先 `lgdt` 再设置 CR0.PE=1**？  
> 如果反过来行不行？

---

### 🧩 一、CPU 在切换 PE=1 前后的行为差异

当 CPU 的 CR0 寄存器的第 0 位（PE 位）为 0 时：

> CPU 按 **实模式** 工作，  
> 段寄存器（如 CS、DS、SS）中的值直接按 “段 × 16 + 偏移” 计算地址。

当你把 **CR0.PE 置 1** 时：

> CPU 的寻址逻辑切换成“保护模式语义”，  
> 也就是说——==从此以后，CPU 解释段寄存器里的值为 **段选择子==（selector）**，  
> 要去 **GDT** 或 **LDT** 查找对应的“段描述符”来获取段基址、权限等。

---

###  💣 如果先设置 CR0.PE=1 而还没加载 GDT 会怎样？

此时 CPU ==会立刻尝试==：

- ==用现在的 CS 寄存器值（原本是实模式的段值）去查 **GDT**==；
    
- 但 **GDT 根本没加载（GDTR 是空的）**；
    
- 所以 CPU 不知道 GDT 在哪里、limit 是多少；
    
- 结果：==**CPU 直接崩溃==（#GP General Protection Fault）**。
    

也就是说：

> 一旦设置 PE=1，CPU 就要求你得有 GDT，  
> 否则它连取下一条指令都不知道段基址在哪儿。



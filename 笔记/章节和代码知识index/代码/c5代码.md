[[c5代码流程]]
学习建立pde,pte


这一章的 loader 主要完成以下几个阶段👇

|阶段|主要功能|
|---|---|
|1️⃣|清空页目录表（Page Directory）|
|2️⃣|建立页目录项（PDE）|
|3️⃣|建立页表项（PTE）|
|4️⃣|把页目录地址写入 `CR3`|
|5️⃣|设置 `CR0.PG = 1` 启用分页|


## 1️⃣ 清空页目录表

代码：

```
PAGE_DIR_TABLE_POS equ 0x100000     ; 页目录表放在物理地址 1MB

mov ebx, PAGE_DIR_TABLE_POS
mov ecx, 4096
xor eax, eax
.clear_page_dir:
    mov [ebx], eax
    add ebx, 1
    loop .clear_page_dir

```


### 🧠 理解：

- 页目录表的大小是 **4KB（4096字节）**，每个条目4字节，共1024项。
    
- 我们先清空它（全部填0），防止里面有垃圾数据。
    

|指令|作用|
|---|---|
|`mov ebx, PAGE_DIR_TABLE_POS`|设置 EBX = 页目录起始地址（1MB处）|
|`mov ecx, 4096`|循环 4096 次|
|`xor eax, eax`|把 EAX 清零|
|`.clear_page_dir:`|循环标签|
|`mov [ebx], eax`|把地址 EBX 处写 0|
|`add ebx, 1`|地址 +1|
|`loop .clear_page_dir`|每次 ECX–1，直到清完 4KB|

💡执行完之后：

> 物理地址 0x100000 ~ 0x100FFF 之间，全是 0。



==（先写个地址出来，然后再得到一个存储值为零的寄存器，然后去对应地址访问，利用寄存器的值将其清0）

## 清零的原因

如果是编译器初始化的静态区变量（像全局变量），系统会帮你清零。  
但如果是你**手动指定内存地址**（比如汇编里直接用 0x100000），那系统不会帮你。

[[内存分区]]

在裸机阶段：

- 没有操作系统；
    
- 没有加载器（loader）；
    
- 你写的汇编直接运行在物理内存上；
    
- CPU 不知道“data区”“bss区”这些概念。
    

所以：

> 你自己必须手动做“清零”的工作，  
> 不然内存里是什么值，CPU也不知道。

## 2️⃣ 建立页目录项（PDE）
[[分页机制&PDEPTE]]

每个页目录项 4 字节，总共 1024 个。  
我们先建立第 0 项——让虚拟地址从 0x00000000 开始映射。

代码：
```
mov eax, PAGE_DIR_TABLE_POS + 0x1000  ; 第一个页表放在 1MB+4KB
or  eax, 0x7                          ; 属性：P=1, RW=1, US=1
mov [PAGE_DIR_TABLE_POS], eax         ; PDE[0] = 页表地址 + 属性

```
### 🧠 解释：



- PDE（页目录项）指向页表的物理地址。
### `mov eax, PAGE_DIR_TABLE_POS + 0x1000`

👉 把第一个**页表**的起始地址放到 `EAX`。

假设：

`PAGE_DIR_TABLE_POS equ 0x100000`

那就是：

`EAX = 0x100000 + 0x1000 = 0x101000`
0x1000是4kb 4096

也就是说：

> 页目录表放在 1MB (0x100000)  
> 页表放在它后面 4KB，也就是 1MB+4KB。



- `0x7` 是三个标志位：


    
    - bit0: P（Present）=1 表示==该页存在==
        
    - bit1: RW（Read/Write）=1 可写bit1： ==RW（读/写==）=1 可写
        
    - bit2: US==（User/Supervisor）===1 所有人可访问
        
- 因为每个页表也是4KB，所以第一个页表放在 `0x101000`（即页目录之后）。
    

💡执行完之后：

> PDE[0] 指向了第一个页表（PTE表）。

---

# 先建立一个页目录项

第一个 PDE 之所以**一定要创建**，原因主要有几个，和是否“马上用到”稍微不一样——它更多是为了**保证内核能顺利启动和访问关键内存**：

1. **映射低端内存（0~4MB）**
    
    - CPU 切换到分页模式后，所有虚拟地址访问都会走页表。
        
    - 即使你暂时还没用到用户空间，内核本身启动、栈、数据段、设备寄存器映射都可能位于低端物理内存。
        
    - 第一个 PDE 对应的页表覆盖低端 4MB，这部分内存必须映射好，否则 CPU 一开始访问这些地址就会发生**缺页异常**，内核就跑不起来。
        
2. **保证页表机制可用**
    
    - 页目录表和页表至少要有一个有效项，否则开启分页（CR0.PG=1）后 CPU 会直接产生异常。
        
    - 所以书中先建第一个 PDE+PTE，其实就是**建立最小可用分页结构**，保证分页能启动。


 **需建立（On-Demand Paging / Lazy Allocation）**

- 操作系统不会一次性把整个 4GB 虚拟地址空间的页表全都建好，这会浪费内存。
    
- 通常先建立**核心使用的那部分虚拟地址**的 PDE+PTE，比如内核映射的低端 1MB 或内核段。
    
- 用户进程或内核需要访问其他地址时，才动态创建对应的页表和页目录项。



## 3️⃣ 建立页表项（PTE）

页表也是4KB，一共有1024个PTE，每个指向一个物理页（4KB）。

代码：

```
mov ebx, PAGE_DIR_TABLE_POS + 0x1000   ; 页表起始地址
mov ecx, 1024                          ; 页表项个数
mov eax, 0x00000007                    ; 第一个页的物理地址 + 属性
.create_pte:
    mov [ebx], eax
    add eax, 0x1000                    ; 下一个物理页（+4KB）
    add ebx, 4                         ; 下一个PTE（+4字节）
    loop .create_pte

```
### 🧠 解释：

| 指令                | 含义                       |
| ----------------- | ------------------------ |
| `ebx=页表地址`        | 我们要往这个页表写数据              |
| `ecx=1024`        | 页表项个数                    |
| `eax=0x00000007`  | 起始物理地址=0 + 属性标志（P、RW、US） |
| `.create_pte`     | 循环创建页表项                  |
| `mov [ebx], eax`  | ==把物理地址+属性写入该PTE==       |
| `add eax, 0x1000` | 下一物理页地址                  |
| `add ebx, 4`      | 下一PTE                    |
| `loop`            | 循环 1024 次                |
（ebx类似数组的下标，对应的就是页表中页的索引的地址，是页表里的，也就是代表着不同的PTE）  
（eax,对应的就是页的物理地址，到时候根据这个访问页，然后加上页内偏移就可以得到物理地址了）
页目录里是表，页表里面是页
```
`eax` 里存的是物理页地址 + 属性
`ebx` 里存的是页表在内存里的地址
```
###  `mov [ebx], eax` 和 `add ebx, 4` → ==页表项大小==

**把某个虚拟页对应的==物理页地址和属性写入页表==，告诉 CPU 这个虚拟页该映射到哪个物理页**。


- 页表（PTE）表里每个项是 **4 字节（32 位）**，存放物理页地址 + 属性。
    
- `mov [ebx], eax` 就是把 eax 的值写到当前 PTE 中。
    
- 写完后 `add ebx, 4`，指针移动到**下一个 PTE**的位置（4B 后）。
    

> 所以这里的 4B 是指**页表项本身的大小**，不是页的大小。

---

### `add eax, 0x1000` → ==页大小==

- 页表项里的物理页地址每次要加 **4KB**，即 `0x1000`。
    
- 因为 x86 的分页机制中，每个 PTE 映射一个 4KB 的物理页。
    
- 这里的 eax 初始值 `0x00000007` 里，低 12 位是页属性，高 20 位是物理页号。
    
- `add eax, 0x1000` 是把物理页地址加 4KB，指向下一个物理页。
    

> 所以这里的 4KB 是指**物理页大小**，对应 CPU 的分页单位。


💡结果：

> 第一个页表完成映射：
> 
> 虚拟地址 0x00000000～0x003FFFFF  
> 都映射到物理地址 0x00000000～0x003FFFFF
> 
> 这叫 **恒等映射（Identity Mapping）**。



## 4️⃣ 把页目录地址写入 CR3

`mov eax, PAGE_DIR_TABLE_POS mov cr3, eax`

### 🧠 解释：

- `CR3` 是 **页目录基址寄存器**，保存页目录的物理地址。
    
- 当分页启用后，==CPU 通过 `CR3` 找到页目录，再查页表。==

## 5️⃣ 启用分页

`mov eax, cr0 or  eax, 0x80000000      ; 设置 CR0.PG = 1 mov cr0, eax`


- 十六进制 `0x80000000` 对应二进制：
    

`1000 0000 0000 0000 0000 0000 0000 0000`

- 这正好是 **第 31 位 = 1，其余位 = 0**
    
- 所以 `0x80000000` = “把 PG 位置 1，其它位不变（如果用 OR 操作）”


### 🧠 解释：

PG ——PAGING 页

- `CR0` 的第 31 位（PG）= 1，就开启了分页。
    
- 之后 CPU 的地址翻译逻辑变为：
    

`逻辑地址 → 段基址（GDT）→ 线性地址 → 页表映射 → 物理地址`

💡 执行完这句后：

> CPU 进入“分页模式（Paging Mode）”。
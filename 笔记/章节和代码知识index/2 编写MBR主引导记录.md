[[c2代码]]
总结：
  利用中断号，借用寄存器填入功能号的参数，实现打印等功能。


在8086计算机开机时，CPU的cs:ip寄存器被强制初试化为0xF000:0xFFF0，在实模式下由于CPU访问的内存是段地址+偏移地址的方式来实现的，所以0xF000:0xFFF0，访问的地址是0xF000*16+0xFFF0=0xFFFF0。

0xFFFF0这个地址存放着一条指令，==该指令内容是跳转至BIOS程序的入口==（该指令由跳转指令与BIOS程序的入口地址组成，共16B)。

BIOS有四个主要功能：
1、硬件自检；
2、建立一些需要用到的数据结构与中断向量表；
3、校验[[启动盘]]中位于0盘0道1扇区（其实就是0扇区，只不过CHS方法用1开头）的内容，校验这里是不是放着主引导记录MBR，校验方法是检测这个扇区最后两个字节是不是0x55与0xaa（所以我们编写的主引导记录MBR最后两个字节应该是这两个）；
4、在3的基础上是，那么就将该扇区内容加载至0x7c00内存处，这个位置是由于历史遗留导致的兼容，由最初的操作系统本身所占内存大小与布局所决定（书p58）。加载完毕后，然后跳转过去执行。

MBR的任务就是加载loader，由loader加载操作系统到指定位置，然后执行加载过来的操作系统。MBR大小必须是512字节，这是为了占满硬盘0盘0道1扇区，且最最后两个字节必须是==0x55与0xaa==。


[[寄存器]]
# 第2章 - 编写 MBR 主引导记录

## 问题 1：实模式寻址

### CPU 在实模式下如何访问内存？

[[实模式]]
[[内存分段机制]]

- 什么是实模式？
- 为什么 8086 CPU 需要分段机制？
- 物理地址如何计算？（段基址 × 16 + 偏移地址）
- 为什么段基址要乘以 16？
- 实模式下能访问多少内存？（1MB）

---

## 问题 2：段寄存器

### 段寄存器的作用是什么？

[[内存分段机制]]
[[寄存器]]

- CS、DS、SS、ES 四个段寄存器的作用？
- 为什么要有专门的栈段寄存器 SS？
- 段寄存器如何初始化？
- MBR 中为什么要设置 DS = 0？

---

## 问题 3：vstart 虚拟起始地址

### NASM 的 vstart 指令是什么？

[[vstart虚拟起始地址]]
[[NASM汇编器]]

- vstart 的作用是什么？
- 为什么 MBR 需要 `vstart=0x7c00`？
- vstart 和实际加载地址的关系？
- `$` 和 `$$` 在 vstart 下的含义？

---

## 问题 4：NASM 汇编语法

### NASM 汇编器的特性和语法？

[[NASM汇编器]]

- NASM 的两趟扫描机制？
- 伪指令：db、dw、dd、times、equ？
- `$` - 当前行地址
- `$$` - 节(section)起始地址
- section 和 vstart 的配合使用？

---

## 问题 5：内存布局

### 实模式下的内存是如何布局的？

[[实模式]]
[[ROM与RAM]]

- 0x00000 - 0x003FF：中断向量表
- 0x00400 - 0x004FF：BIOS 数据区
- 0x00500 - 0x07BFF：可用区域
- 0x07C00 - 0x07DFF：MBR 加载位置
- 0x80000 - 0x9FFFF：扩展 BIOS 数据区
- 0xA0000 - 0xBFFFF：显存区域
- 0xC0000 - 0xFFFFF：BIOS ROM

---

## 问题 6：ROM 和 RAM

### ROM 和 RAM 的区别？

[[ROM与RAM]]

- ROM：只读存储器，断电不丢失
- RAM：随机访问存储器，断电丢失
- BIOS 为什么要存储在 ROM 中？
- Flash 闪存是 ROM 还是 RAM？

---

## 问题 7：栈

### 栈在汇编中如何工作？

[[栈与指针]]
[[RET与CALL指令]]

- 栈是向下增长的（栈底是高地址）
- SS:SP 指向栈顶
- push 和 pop 指令的工作原理？
- call 和 ret 如何利用栈保存返回地址？

---

## 问题 8：CALL 和 RET

### 函数调用机制是如何实现的？

[[RET与CALL指令]]

- call 指令做了什么？（push IP/EIP，然后跳转）
- ret 指令做了什么？（pop IP/EIP）
- near call 和 far call 的区别？
- 为什么不能直接 `mov IP, xxxx`？

---

## 问题 9：FLAGS 寄存器

### FLAGS 寄存器存储了哪些状态标志？

[[FLAGS寄存器]]

- CF (Carry Flag)：进位标志
- ZF (Zero Flag)：零标志
- SF (Sign Flag)：符号标志
- OF (Overflow Flag)：溢出标志
- IF (Interrupt Flag)：中断允许标志
- 为什么需要 FLAGS 寄存器？
- 条件跳转指令如何使用 FLAGS？

---

## 问题 10：条件跳转

### jz、jnz 等条件跳转指令如何工作？

[[FLAGS寄存器]]

- jz / je：ZF=1 时跳转（结果为零）
- jnz / jne：ZF=0 时跳转（结果非零）
- jc：CF=1 时跳转（有进位）
- js：SF=1 时跳转（结果为负）
- jo：OF=1 时跳转（有溢出）

---

## 问题 11：编写和运行 MBR

### 如何编译、写入和测试 MBR？

[[MBR主引导记录]]
[[NASM汇编器]]

```bash
# 编译 MBR
nasm -o mbr.bin mbr.asm

# 写入硬盘镜像
dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc

# 用 Bochs 运行
bochs -f bochsrc.disk
```

- dd 命令的参数含义？
- conv=notrunc 的作用？
- 如何用 Bochs 调试 MBR？



# 📚 操作系统真象还原 - 完整讲解

## 一、整体思路

### 1.1 项目目标

**从零开始,用C语言和汇编语言编写一个能在x86硬件(或Bochs虚拟机)上运行的操作系统**

 

包含的核心功能:

- ✅ 引导加载(Boot Loader)
- ✅ 内存管理
- ✅ 进程/线程管理
- ✅ 文件系统
- ✅ 系统调用
- ✅ Shell命令行
- ✅ 进程间通信(管道)

### 1.2 技术栈

```
硬件层: x86 CPU (保护模式)
     ↓
虚拟机: Bochs 模拟器
     ↓
开发工具: gcc-4.4 (交叉编译), nasm (汇编器), Docker (环境隔离)
     ↓
语言: C语言 + x86汇编
     ↓
存储: 虚拟硬盘镜像 (hd60M.img, hd80M.img)
```

### 1.3 整体架构

```
┌─────────────────────────────────────┐
│   用户程序 (User Programs)           │
│   cat, prog_pipe, shell             │
├─────────────────────────────────────┤
│   系统调用层 (System Call)           │
│   fork, exec, read, write, open...  │
├─────────────────────────────────────┤
│   内核核心 (Kernel Core)             │
│   ├─ 进程管理 (Process/Thread)      │
│   ├─ 内存管理 (Memory Management)   │
│   ├─ 文件系统 (File System)         │
│   └─ 设备驱动 (Device Drivers)      │
├─────────────────────────────────────┤
│   引导加载器 (Boot Loader)           │
│   MBR → Loader → Kernel             │
├─────────────────────────────────────┤
│   硬件层 (Hardware/Bochs)            │
└─────────────────────────────────────┘
```

---

## 二、启动流程详解

### 2.1 计算机加电后的启动过程

```
BIOS → MBR → Loader → Kernel → Init进程 → Shell
```

#### **阶段1: BIOS (Basic Input/Output System)**

```
┌──────────────────────────────────────┐
│ 1. CPU上电,执行BIOS固化程序          │
│ 2. BIOS自检硬件(内存、硬盘等)         │
│ 3. BIOS读取硬盘第0扇区(MBR)到内存    │
│    地址: 0x7c00                      │
│ 4. 跳转到 0x7c00 执行MBR代码         │
└──────────────────────────────────────┘
```

#### **阶段2: MBR (Master Boot Record) - 主引导记录**



好的,让我用图解的方式来讲解,不依赖具体代码:

---

## 二、启动流程详解(续)

### **阶段2: MBR (主引导记录)**

**MBR的任务:**

```assembly
┌─────────────────────────────────────┐
│ MBR (占用硬盘第0扇区,512字节)        │
│                                     │
│ 1. 初始化段寄存器 (ds,es,ss,sp)     │
│ 2. 清屏,显示 "1 MBR" 提示           │
│ 3. 从硬盘读取Loader到内存           │
│    - 位置: 扇区2开始,共4个扇区      │
│    - 目标内存: 0x900               │
│ 4. 跳转到Loader执行                │
└─────────────────────────────────────┘
```

**硬盘布局:**

```
扇区0:   MBR (512字节)
扇区1:   保留
扇区2-5: Loader (4个扇区, 2KB)
扇区6-8: 保留
扇区9+:  Kernel (内核,从扇区9开始)
```

### **阶段3: Loader (加载器)**

**Loader的任务更复杂:**

```
┌─────────────────────────────────────┐
│ Loader的核心工作:                   │
│                                     │
│ 1. 进入保护模式                     │
│    ├─ 打开A20地址线 (突破1MB限制)  │
│    ├─ 加载GDT (全局描述符表)       │
│    └─ 设置CR0寄存器开启保护模式    │
│                                     │
│ 2. 启用分页机制                     │
│    ├─ 设置页目录表(PDE)            │
│    ├─ 设置页表(PTE)                │
│    └─ 设置CR3寄存器启用分页        │
│                                     │
│ 3. 加载内核到内存                   │
│    - 从硬盘扇区9开始读取           │
│    - 加载到内存 0xc0001500         │
│                                     │
│ 4. 跳转到内核入口执行               │
└─────────────────────────────────────┘
```

**关键概念: 实模式 vs 保护模式**

```
┌─────────────────────┬─────────────────────┐
│   实模式 (Real Mode) │  保护模式 (Protected)│
├─────────────────────┼─────────────────────┤
│ 16位寻址             │  32位寻址            │
│ 最大1MB内存          │  4GB内存             │
│ 直接访问物理地址     │  通过段描述符访问    │
│ 无内存保护           │  有特权级保护(0-3级) │
│ BIOS、MBR使用        │  现代OS使用          │
└─────────────────────┴─────────────────────┘
```

### **阶段4: Kernel (内核初始化)**

让我看看kernel的main.c:

Read [init.c](vscode-webview://0jr9jcn3fo4cbv76t25prprgpvopkaf58pdhc92s5mqrgk729d8a/index.html?id=8d1ef223-f622-4c49-98c3-9af7495502bb&parentId=2&origin=5f7ad470-91d7-40e8-bcb2-82f15eb531ec&swVersion=4&extensionId=Anthropic.claude-code&platform=electron&vscode-resource-base-authority=vscode-resource.vscode-cdn.net&parentOrigin=vscode-file%3A%2F%2Fvscode-app&session=47e188d5-be60-414f-a28a-7e6a97aebd33#)

完美!现在让我完整讲解内核初始化:

### **阶段4: Kernel初始化流程**

```c
main() {
    put_str("I am kernel\n");  // 打印内核启动信息
    init_all();                // 初始化所有模块
    
    // 启动第一个用户进程
    process_execute(init, "init");
    
    // 主线程进入空闲状态
    while(1) {
        thread_block(TASK_BLOCKED);
    }
}
```

**init_all() 初始化顺序:**

```
1. idt_init()      → 中断描述符表 (处理硬件中断、异常)
2. mem_init()      → 内存管理 (物理内存、虚拟内存、内存池)
3. thread_init()   → 线程系统 (就绪队列、线程PCB)
4. timer_init()    → 定时器 (PIT 8253芯片,时间片调度)
5. console_init()  → 控制台 (屏幕输出)
6. keyboard_init() → 键盘驱动 (处理键盘输入)
7. tss_init()      → 任务状态段 (用户态↔内核态切换)
8. syscall_init()  → 系统调用表 (用户程序调用内核服务)
9. ide_init()      → 硬盘驱动 (ATA/IDE磁盘控制器)
10. filesys_init() → 文件系统 (超级块、inode、目录)
```

### **阶段5: Init进程与Shell**

```c
void init(void) {
    uint32_t ret_pid = fork();  // 创建子进程
    
    if (ret_pid) {  // 父进程 (init进程, pid=1)
        while(1) {
            child_pid = wait(&status);  // 回收僵尸进程
            printf("回收子进程 pid=%d\n", child_pid);
        }
    }
    else {  // 子进程
        my_shell();  // 启动Shell
    }
}
```

**进程树结构:**

```
idle进程 (pid=0, 内核主线程)
  └─ init进程 (pid=1)
       └─ shell进程 (pid=2)
            ├─ cat进程 (用户执行命令时创建)
            ├─ ls进程
            └─ ...
```

---

## 三、核心子系统详解

### 3.1 内存管理

```
物理内存布局:
┌──────────────────┬─────────────┐
│ 0x0 - 0x9FFFF    │ 640KB       │ 低端内存 (BIOS、MBR、Loader)
├──────────────────┼─────────────┤
│ 0xA0000-0xFFFFF  │ 384KB       │ 显存、ROM
├──────────────────┼─────────────┤
│ 0x100000+        │ ...         │ 高端内存 (内核、用户程序)
└──────────────────┴─────────────┘

虚拟内存映射:
┌──────────────────┬─────────────┐
│ 0xc0000000+      │ 内核空间    │ 3GB-4GB (内核独占)
├──────────────────┼─────────────┤
│ 0x0 - 0xbfffffff │ 用户空间    │ 0-3GB (每个进程独立)
└──────────────────┴─────────────┘
```

**分页机制:**

```
虚拟地址 → [页目录表] → [页表] → 物理地址
   32位        10位       10位      12位偏移
```

### 3.2 进程/线程管理

**PCB (Process Control Block) 结构:**

```c
struct task_struct {
    uint32_t* self_kstack;     // 内核栈指针
    enum task_status status;   // 线程状态 (运行/就绪/阻塞)
    char name[16];             // 线程名
    uint8_t priority;          // 优先级
    uint32_t ticks;            // 时间片
    uint32_t elapsed_ticks;    // 已运行时间
    struct list_elem general_tag;  // 通用队列节点
    struct list_elem all_list_tag; // 全部线程队列
    uint32_t* pgdir;           // 页目录表虚拟地址
    uint32_t pid;              // 进程ID
    int32_t fd_table[MAX_FILES]; // 文件描述符表
    // ...
};
```

**调度算法: 时间片轮转**

```
就绪队列: [进程A(5ticks)] → [进程B(3ticks)] → [进程C(8ticks)]
                 ↓ 定时器中断
           [进程B(3ticks)] → [进程C(8ticks)] → [进程A(4ticks)]
```

### 3.3 文件系统

**磁盘布局:**

```
┌─────────────┬───────────────────────────────┐
│ MBR (1扇区)  │ 扇区0                         │
├─────────────┼───────────────────────────────┤
│ 分区表       │ 超级块、inode位图、块位图     │
├─────────────┼───────────────────────────────┤
│ inode数组    │ 每个文件/目录的元数据         │
├─────────────┼───────────────────────────────┤
│ 数据块       │ 实际文件内容                  │
└─────────────┴───────────────────────────────┘
```

**文件系统关键结构:**

```
超级块(super_block) → 记录整个文件系统信息
inode              → 文件元数据 (大小、位置、权限)
目录项(dir_entry)  → 文件名 → inode号映射
```

### 3.4 系统调用

**用户态调用内核服务的桥梁:**

```
用户程序:  write(fd, buf, size)
              ↓
lib/syscall.c: 封装int 0x80中断
              ↓
内核态:    syscall_handler() 
              ↓
           sys_write() 实际实现
```

**系统调用表:**

```c
enum SYSCALL_NR {
    SYS_GETPID,     // 0: 获取进程ID
    SYS_WRITE,      // 1: 写文件
    SYS_MALLOC,     // 2: 分配内存
    SYS_FREE,       // 3: 释放内存
    SYS_FORK,       // 4: 创建进程
    SYS_READ,       // 5: 读文件
    SYS_PUTCHAR,    // 6: 输出字符
    SYS_CLEAR,      // 7: 清屏
    // ...
};
```

---

## 四、开发工作流

### 4.1 编译流程

```bash
# 在Docker中编译 (使用gcc-4.4)
docker run --rm \
  -v "$(pwd)":/workspace \
  -v ~/真象还原/bochs:/bochs \
  myos-gcc:4.4 bash -c "cd /workspace && make all"
```

**Makefile工作流程:**

```
1. 编译汇编文件
   mbr.S  → nasm → mbr.o   (512字节,扇区0)
   loader.S → nasm → loader.o (2KB,扇区2-5)

2. 编译C文件
   main.c, memory.c, ... → gcc → .o文件

3. 编译汇编内核代码
   kernel.S, print.S, ... → nasm → .o文件

4. 链接所有.o文件
   ld → kernel.bin (内核ELF文件)

5. 写入虚拟硬盘
   dd if=mbr.o of=hd60M.img bs=512 count=1 seek=0
   dd if=loader.o of=hd60M.img bs=512 count=4 seek=2
   dd if=kernel.bin of=hd60M.img bs=512 count=200 seek=9
```

### 4.2 运行流程

```bash
cd ~/真象还原/bochs
bin/bochs -f bochsrc.disk
```

**Bochs配置 (bochsrc.disk):**

```
megs: 32                    # 32MB内存
boot: disk                  # 从硬盘启动
ata0-master: hd60M.img      # 主硬盘 (系统盘)
ata0-slave: hd80M.img       # 从硬盘 (数据盘,文件系统)
```

### 4.3 调试流程

```bash
# 生成调试符号
make gdb_symbol

# 启动bochs调试模式
bochs -f bochsrc.disk

# 在bochs中设置断点
<bochs:1> lb 0xc0001500   # 在内核入口设置断点
<bochs:2> c               # 继续执行
<bochs:3> r               # 查看寄存器
<bochs:4> x /10 0xc0001500 # 查看内存
```

---

## 五、Chapter 15 的学习路径

### 5.1 各章节功能演进

```
chapter_15/a: fork基础
              └→ 实现进程创建,父子进程打印pid

chapter_15/b: Shell框架
              └→ 能接收用户输入,显示提示符

chapter_15/c-d: Shell完善
              └→ 命令解析

chapter_15/e: 内建命令
              └→ cd, ls, ps, clear等

chapter_15/f-h: 命令扩展
              └→ mkdir, rmdir, rm, pwd等

chapter_15/i: exec & wait
              └→ 执行外部程序,等待子进程结束

chapter_15/j: 管道(Pipe)
              └→ 进程间通信 command1 | command2

chapter_15/k: I/O重定向
              └→ cat < input.txt > output.txt
```

### 5.2 你修改过的问题

**原始代码的问题:**

1. ❌ 硬盘路径错误 (`/home/rlk/Desktop/bochs/hd60M.img`)
2. ❌ 缺少第二块硬盘 (文件系统需要sdb)
3. ❌ main.c直接加载cat程序导致启动失败

**你的修复:**

1. ✅ 修改所有makefile的HD60M_PATH为 `/bochs/hd60M.img`
2. ✅ 创建hd80M.img并配置为ata0-slave
3. ✅ 修改k/kernel/main.c注释掉cat加载,改用process_execute(init)

---

## 六、核心概念总结

### 6.1 为什么需要两块硬盘?

```
hd60M.img (sda) - 系统盘
  ├─ 扇区0: MBR
  ├─ 扇区2-5: Loader  
  └─ 扇区9+: Kernel

hd80M.img (sdb) - 数据盘
  └─ 分区sdb1: 文件系统 (用户文件、目录)
```

### 6.2 为什么使用Docker?

```
问题: gcc版本不兼容
  - 现代gcc (>= 5.0) 编译选项和行为变化
  - 老代码需要gcc-4.4

解决: Docker容器隔离
  - myos-gcc:4.4 镜像包含正确的编译器
  - 不影响宿主机环境
```

### 6.3 关键地址空间

```
0x7c00      : MBR加载地址
0x900       : Loader加载地址
0xc0001500  : Kernel入口地址 (虚拟地址)
0x100000    : Kernel物理地址 (1MB处)
0xc0000000+ : 内核虚拟地址空间起始
```

---

## 七、下一步学习建议

1. **按顺序学习**: 从chapter_15/a开始,逐步到k
2. **理解每个新增功能**: 对比相邻章节的diff
3. **调试运行**: 使用bochs的调试功能单步执行
4. **修改实验**: 尝试添加自己的系统调用或命令

**核心要掌握的知识点:**

- ✅ x86保护模式和分页机制
- ✅ 中断和异常处理
- ✅ 进程调度和上下文切换
- ✅ 虚拟内存管理
- ✅ 文件系统设计
- ✅ 系统调用机制

有任何具体问题或想深入了解某个模块,都可以继续问我! 🚀

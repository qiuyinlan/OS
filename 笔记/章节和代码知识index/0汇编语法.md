[[16进制]]
# 内存地址

mov 目标, 源

`[gs:0x00]` 的意思是：

> ==用 GS 作为段寄存器，偏移为 0x00==，  
> 访问这个内存位置


# 显存

mov byte\[gs:0x00], '1'
mov 本来就表示 “把值放到某个地方”。

这里的 \[gs:0x00] 指向的是一个内存单元，它不是寄存器，所以 CPU 的动作是：

把 '1' 放（写）到那块内存里。





`byte` 是告诉汇编器：

> “我要往这个地址写一个 1 字节的数据”

因为一个字符 `'1'` 只占 1 字节。

mov \[gs:0x00], '1'
这里 '1' 是个立即数，它可以被 CPU 当成 8 位、16 位、32 位都行，CPU没法自动猜。
**所以必须明确告诉它：这是 1 字节 👇**

`mov byte [gs:0x00], '1'`

如果写 4 字节，就用：

`mov dword [gs:0x00], 1234`

如果写 2 字节：

`mov word [gs:0x00], 0xABCD`

2. 那为什么寄存器就不用写大小？

因为寄存器**名字里已经带了大小信息**：

- AL → 8-bit
    
- AX → 16-bit
# 赋值

在汇编里，“赋值”这个动作本质上就是：

> **把一个值“写入”某个内存地址**。

换句话说：

- **高级语言说：** 赋值
    
- **汇编说：** 写内存



 8086 不允许 mov ds, 0（不能直接给段寄存器赋立即数）
必须通过通用寄存器中转

# dd

### dd 命令是什么？

**答：** 它是"精确复制工具"，用来把文件内容复制到磁盘镜像的指定位置。
```bash
dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
```

**逐个解释：**

|部分|意思|白话翻译|
|---|---|---|
|`if=mbr.bin`|输入是 mbr.bin|"从 mbr.bin 文件读数据"|
|`of=hd60M.img`|输出到 hd60M.img|"写到 hd60M.img 文件"|
|`bs=512`|块大小512字节|"每次处理512字节"|
|`count=1`|复制1块|"只复制1次（512字节）"|
|`conv=notrunc`|转换选项：不截断|"不要删除目标文件原有的其他内容"|

**结果：** 把 mbr.bin 的前512字节写到 hd60M.img 的开头，但保留 hd60M.img 原有的其他内容### 实际操作流程：

```
1. 编译你的代码：
   mbr.asm → mbr.o (引导代码，512字节)
   loader.asm → loader.o (加载器，2048字节=4块)
   kernel.c → kernel.bin (内核，最多200块)

2. 用 dd 把它们写入虚拟硬盘：
   dd ... mbr.o → hd60M.img 的第1个扇区
   dd ... loader.o → hd60M.img 的第3-6个扇区
   dd ... kernel.bin → hd60M.img 的第10-209个扇区
```
# bit

\[bits 16]
\[bits 32]
它的作用是：

> “告诉汇编器：你下面写的 mov/add/jmp 等指令，应该被翻译成 16 位还是 32 位机器码”。
# **0x66**

_**切换操作数大小**_ 假设当前运行模式是 16 位实模式，操作数大小将变为 32 位。 假设当前运行模式是 32 位保护模式，操作数大小将变为 16 位
它才是 CPU 认识的东西。

功能：

> **临时反转操作数宽度（16 ↔ 32）**

### 在 16 位模式下（默认操作数 = 16 位）

0x66 会使得：

`mov ax, 1234h    ; 正常 16 位 66 mov ax, 1234h ; 编译器会把它转成 mov eax, 1234h`

CPU 会用 **32 位寄存器**（EAX）执行这条指令。

### 在 32 位模式下（默认操作数 = 32 位）

0x66 会使得：

`mov eax, 12345678h   ; 正常 32 位 66 mov eax, 1234h    ; 变成 mov ax, 1234h（16 位）`

总结：

| 当前模式      | 默认操作数 | 0x66 后会变成 |
| --------- | ----- | --------- |
| 实模式 16 位  | 16 位  | 32 位      |
| 保护模式 32 位 | 32 位  | 16 位      |
# **0x67**

**寻址方式反转前缀** 如果想在 32 位模式下 使用 16 位内存地址（相当于 bx），你必须加上 0x67 前缀来反转地址模式：16位 同理
> **反转寻址方式（address size）**

### 在 16 位模式下（默认寻址 = 16 位，BX+SI 那种）

0x67 会让你使用 32 位寻址：

`mov eax, [ebx]   ; 在 16 位模式下不允许 67 mov eax, [ebx] ; 加 0x67 才能用 32 位地址`

### 在 32 位模式下（默认寻址 = 32 位）

0x67 可以让你使用 16 位寻址方式：

`mov ax, [bx]     ; 在 32 位模式下非法 67 mov ax, [bx]  ; 加上 0x67 后允许`

总结：

| 当前模式 | 默认寻址方式            | 0x67 后变成          |
| ---- | ----------------- | ----------------- |
| 16 位 | 16-bit addressing | 32-bit addressing |
| 32 位 | 32-bit addressing | 16-bit addressing |


# `push` 和 `pop` 的作用

### 1️⃣ `push 寄存器`

- **操作**：把寄存器里的值压入栈顶（内存中 ESP 指向的位置）。
    
- **结果**：
    
    1. 栈向低地址生长（ESP 减小）。
        
    2. 栈顶现在存了这个寄存器的值。
        
- **寄存器本身的值不会改变**（只是复制到栈里）。
    

例子：

`mov eax, 5 push eax   ; 把 eax = 5 压入栈`

- 栈上多了一份 5
    
- ESP 自动减小
    
- EAX 仍然是 5
    

---

### 2️⃣ `pop 寄存器`

- **操作**：把栈顶的值弹出到寄存器中。
    
- **结果**：
    
    1. 寄存器被更新为栈顶的值
        
    2. ESP 增加，栈顶上移，相当于“释放”这块栈空间
        

例子：

`pop ebx   ; 把栈顶值放入 ebx`

- EBX 得到栈顶的值
    
- ESP 向上移动，原栈顶空间可重用
# equ

```
LOADER_BASE_ADDR equ 0x9000
```


- `equ` 是汇编语言里的 **等号定义指令**（相当于 C 语言里的 `#define`）。
- `EQU` 只能用来定义 **常量或固定表达式**。  
不能拿来定义可变的变量

### 小结表：

| 功能      | EQU       | DEFINE（或 %define） |
| ------- | --------- | ----------------- |
| 类型      | 符号常量      | 宏替换               |
| 可用于     | 数值、地址、表达式 | 任意指令、文本替换         |
| 是否占内存   | ❌ 否       | ❌ 否               |
| 执行时是否存在 | ❌ 仅汇编期    | ❌ 仅汇编期            |
| 对应 C 语言 | ==const== | `#define`         |


- 这句话定义了一个常量：
    
    `LOADER_BASE_ADDR = 0x9000`
    
- 意思是：**Loader 程序将被加载到内存的物理地址 0x9000 处开始运行。**



LOADER_STACK_TOP equ LOADER_BASE_ADDR
含义：
这行定义 loader 程序的栈顶地址（stack top）为 0x9000。

因为==栈是从高地址向低地址增长==的，所以：
[[内存的高低地址]]

它一开始的顶端是 0x9000；

然后执行 push 或调用函数时，栈指针 esp 会往下（减小地址）移动。


# desc

## `desc` 是什么？

`desc` → 全称是 **descriptor**  
中文叫 **“描述符”**。


# 进制表示
## 在汇编语言中——每种进制都有“标志”

| 进制       | 举例             | 说明                            |
| -------- | -------------- | ----------------------------- |
| **二进制**  | `1010b`        | 末尾加 `b`（Binary）               |
| **十六进制** | `0x1A` 或 `1Ah` | 加 `0x`（C风格）或 `h`（MASM/TASM风格） |
| **十进制**  | `10` 或 `10d`   | 默认是十进制（可不加）                   |
| **八进制**  | `12o` 或 `12q`  | 少用，加 `o` 或 `q` 表示 Octal       |

---

## 🧩 二、不同汇编器的写法略有不同

| 汇编器                    | 二进制          | 十六进制    | 说明      |
| ---------------------- | ------------ | ------- | ------- |
| **NASM（常用）**           | `1010b`      | `0x1A`  | ✅推荐这种写法 |
| **MASM/TASM（老式）**      | `1010b`      | `1Ah`   | 老式写法    |
| **AT&T（GAS, Linux常用）** | `%1010`（很少见） | `$0x1A` | 前缀风格    |


## 定义

| 指令   | 含义                       | 举例                      | 占用字节 |
| ---- | ------------------------ | ----------------------- | ---- |
| `db` | define byte（定义字节）        | `db 0x12`               | 1 字节 |
| `dw` | define word（定义字）         | `dw 0x1234`             | 2 字节 |
| `dd` | define double word（定义双字） | `dd 0x12345678`         | 4 字节 |
| `dq` | define quad word（定义四字）   | `dq 0x1234567890ABCDEF` | 8 字节 |
0x ，1抵4位二进制
8位是一字节，所以8/4=2,2个0x抵一个字节

==一字节： 0x两位  b8位==

# or

`or` 指令表示按位 **逻辑或**
**只要任意一位是 1，结果就是 1**。
（或：就是都可以，只要有一个1）

# xor

`xor` 是“异或”指令。  异或 XOR：**相同为0，==不同为1==；自己异或自己等于0。**
## 生活小例子来理解 “异”

想象你和朋友穿衣服：

| 你穿的 | 朋友穿的 | 异或结果 | 说明             |
| --- | ---- | ---- | -------------- |
| 黑衣服 | 黑衣服  | 0    | 一样，不异，不算       |
| 黑衣服 | 白衣服  | 1    | ==不一样（异），算一个== |
| 白衣服 | 黑衣服  | 1    | 不一样（异），算一个     |
| 白衣服 | 白衣服  | 0    | 一样，不异，不算       |

所以“异或”其实就是：

> “我俩衣服==颜色不一样时亮灯，一样就灭灯==。”


任何数==和自己异或==都等于 0

你可以清零任何寄存器：

|指令|效果|
|---|---|
|`xor eax, eax`|清零 EAX|
|`xor ebx, ebx`|清零 EBX|
|`xor ecx, ecx`|清零 ECX|


> **排他性或”**  
> 或者简称“**异或**”。

这名字是从“**或（OR）**”发展出来的。

我们先看普通的“或”：

> “A 或 B 为真，只要有一个为真即可。”  
> ——也就是说，如果两个都真，也没问题。

但有时候我们想表达：

> “只能选一个为真，两个都真就不行。”

==这种“只能选一个”的情况就叫 **排他性或==（exclusive OR）**。



# in out

在 x86 架构里，CPU 和外设（比如键盘、显卡、声卡、A20控制口等等）**不是直接通过内存通信的**，  
而是通过一套 **独立的 I/O 地址空间** 来通信。

CPU 有==两种访问方式==：

| 类型       | 指令                  | 地址空间              | 用途    |
| -------- | ------------------- | ----------------- | ----- |
| 访问==内存== | `mov`、`add`、`cmp` 等 | 内存地址（RAM）         | 操作数据  |
| 访问==外设== | `in`、`out`          | **I/O 端口号（Port）** | 和硬件通信 |


- 就像“内存有地址”，每个外设也有它的“端口号”。
    
- CPU 通过这个编号找到具体的硬件控制器。

比如👇

|设备|端口号|说明|
|---|---|---|
|键盘控制器|0x60|读取键值|
|控制键盘命令|0x64|写入控制命令|
|A20 控制端口|0x92|控制 A20 地址线开关|
|CMOS 时钟|0x70、0x71|读写时间|

---

## 指令详解

### `in al, 0x92`

意思是：

> 从端口号 `0x92` 读入一个字节，存放到寄存器 `AL` 里。

过程如下：

`CPU 发送端口号 0x92 → 主板 I/O 控制芯片找到对应硬件 → 返回一个字节数据 → 存入 AL`

比如：

`in al, 0x60   ; 从键盘数据端口读取键值`

就能拿到当前按下的键盘扫描码。

---

### `out 0x92, al`

意思是：

> 把 AL 中的值写到端口号 0x92 对应的硬件里。


# 标签（xx：）

汇编中标签的写法非常简单：

`<名字>:`

例如：

`.loop_begin: .clear_page_dir: next_step:`

💡 有时候前面加一个点 `.`（像 `.clear_page_dir:`），有时候不加。区别如下👇

|标签写法|作用范围|示例|
|---|---|---|
|`clear_page_dir:`|全局标签（任何地方都能跳）|`jmp clear_page_dir`|
|`.clear_page_dir:`|局部标签（只在当前代码块里有效）|`loop .clear_page_dir`|


## 汇编里确实没有“函数”的概念（在裸机阶段）

比如：

| 阶段         | 程序运行环境                                                                                                                    | 举例                         |
| ---------- | ------------------------------------------------------------------------------------------------------------------------- | -------------------------- |
| **裸机阶段**   | 没有操作系统，CPU一开机就执行你写的汇编                                                                                                     | BIOS、bootloader、早期内核初始化    |
| **操作系统阶段** | 有系统提供内存、文件、栈空间等支持。特点：<br><br>- 你已经有栈（能保存返回地址）；<br>    <br>- 有了`call` / `ret`，可以真正用“函数式”结构。<br>    <br>- 有时甚至可以和C语言函数互相调用。 | Linux、Windows、macOS 等      |
| **用户程序阶段** | 在操作系统上运行的普通程序                                                                                                             | C语言写的 `main()`、Python、浏览器等 |

你说得对！  
在你现在写的那种汇编（比如《操作系统真相还原》里的 loader 或内核初始化代码）里，确实还没有“函数”。  
那时我们写的都是**一整块连续的指令**，靠标签和跳转（`jmp` / `call` / `loop`）来控制执行流程。

不过，汇编的标签可以理解成“函数的前身”：

- 标签相当于给某个位置取了个名字；
    
- `jmp label` 跳过去；
    
- `call label` 跳过去并保存返回位置；
    
- `ret` 再跳回来。
    

👉 所以当你学到 `call` / `ret` 之后，你就会发现“函数”其实就是**一段带标签、能跳回来的代码块**。

---

## 🌸 二、那“全局”和“局部”到底是什么？

我们先看个例子：

```
main:
    jmp .next
.next:
    nop

```

这里 `.next` 前面有个点 `.`，表示——

> 这是==“main”标签下面的局部标签，只能在 main 的代码块里被引用==。

如果你在别的地方写：

`other:     jmp .next    ; ❌ 报错：找不到 .next`

就不行，因为 `.next` 只属于 `main` 这个区域。


# loop


## `loop` 是干什么的？

`loop` 是一个 **循环指令**，它的作用是：

> 让程序重复执行某一段代码，直到寄存器 **`CX`（或 32 位模式下的 `ECX`）为 0**。

也就是说，`loop` 自带“计数器”的功能。每执行一次，它就自动：

1. 让 `CX` 减 1；
    
2. 如果结果不为 0，就跳转到指定标签；
    
3. 如果结果是 0，就继续往下执行。
    

---

## 🧱 二、基本语法

`loop label`

意思是：

> CX ← CX - 1  
> 如果 CX ≠ 0，则跳转到 `label`；  
> 如果 CX = 0，则继续往下执行。


# \[寄存器]  mov \[ebx], eax


## 对比举例更好理解：

| 指令               | 含义                         | 举例（假设 EBX = 0x100000, EAX = 1234） |
| ---------------- | -------------------------- | --------------------------------- |
| `mov eax, ebx`   | 把 EBX 里的数复制给 EAX           | EAX = 0x100000                    |
| `mov [ebx], eax` | 把 EAX 的值写进 ==EBX 指向的内存地址== | 内存[0x100000] = 1234               |
| `mov eax, [ebx]` | 从 EBX ==指向==的内存里读出数据到 EAX  | EAX = 内存[0x100000] 的值             |
